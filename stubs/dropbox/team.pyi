# -*- coding: utf-8 -*-
# Auto-generated by Stone, do not modify.
# @generated
# flake8: noqa
# pylint: skip-file

from typing import (
    Callable,
    List,
    Optional,
    Text,
    Type,
    TypeVar,
)

import datetime
from stone.backends.python_rsrc import stone_base as bb  # type: ignore
from stone.backends.python_rsrc import stone_validators as bv  # type: ignore

from dropbox import account  # type: ignore
from dropbox import async_  # type: ignore
from dropbox import common  # type: ignore
from dropbox import file_properties  # type: ignore
from dropbox import files  # type: ignore
from dropbox import secondary_emails  # type: ignore
from dropbox import team_common  # type: ignore
from dropbox import team_policies  # type: ignore
from dropbox import users  # type: ignore
from dropbox import users_common  # type: ignore

T = TypeVar('T', bound=bb.AnnotationType)
U = TypeVar('U')

class DeviceSession(bb.Struct):
    def __init__(self,
                 session_id: Text = ...,
                 ip_address: Optional[Text] = ...,
                 country: Optional[Text] = ...,
                 created: Optional[datetime.datetime] = ...,
                 updated: Optional[datetime.datetime] = ...) -> None: ...
    session_id: bb.Attribute[Text] = ...
    ip_address: bb.Attribute[Optional[Text]] = ...
    country: bb.Attribute[Optional[Text]] = ...
    created: bb.Attribute[Optional[datetime.datetime]] = ...
    updated: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeviceSession_validator: bv.Validator = ...

class ActiveWebSession(DeviceSession):
    def __init__(self,
                 session_id: Text = ...,
                 user_agent: Text = ...,
                 os: Text = ...,
                 browser: Text = ...,
                 ip_address: Optional[Text] = ...,
                 country: Optional[Text] = ...,
                 created: Optional[datetime.datetime] = ...,
                 updated: Optional[datetime.datetime] = ...,
                 expires: Optional[datetime.datetime] = ...) -> None: ...
    session_id: bb.Attribute[Text] = ...
    user_agent: bb.Attribute[Text] = ...
    os: bb.Attribute[Text] = ...
    browser: bb.Attribute[Text] = ...
    ip_address: bb.Attribute[Optional[Text]] = ...
    country: bb.Attribute[Optional[Text]] = ...
    created: bb.Attribute[Optional[datetime.datetime]] = ...
    updated: bb.Attribute[Optional[datetime.datetime]] = ...
    expires: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ActiveWebSession_validator: bv.Validator = ...

class AddSecondaryEmailResult(bb.Union):
    other: AddSecondaryEmailResult = ...

    def is_success(self) -> bool: ...

    def is_unavailable(self) -> bool: ...

    def is_already_pending(self) -> bool: ...

    def is_already_owned_by_user(self) -> bool: ...

    def is_reached_limit(self) -> bool: ...

    def is_transient_error(self) -> bool: ...

    def is_too_many_updates(self) -> bool: ...

    def is_unknown_error(self) -> bool: ...

    def is_rate_limited(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: secondary_emails.SecondaryEmail) -> AddSecondaryEmailResult: ...

    @classmethod
    def unavailable(cls, val: Text) -> AddSecondaryEmailResult: ...

    @classmethod
    def already_pending(cls, val: Text) -> AddSecondaryEmailResult: ...

    @classmethod
    def already_owned_by_user(cls, val: Text) -> AddSecondaryEmailResult: ...

    @classmethod
    def reached_limit(cls, val: Text) -> AddSecondaryEmailResult: ...

    @classmethod
    def transient_error(cls, val: Text) -> AddSecondaryEmailResult: ...

    @classmethod
    def too_many_updates(cls, val: Text) -> AddSecondaryEmailResult: ...

    @classmethod
    def unknown_error(cls, val: Text) -> AddSecondaryEmailResult: ...

    @classmethod
    def rate_limited(cls, val: Text) -> AddSecondaryEmailResult: ...

    def get_success(self) -> secondary_emails.SecondaryEmail: ...

    def get_unavailable(self) -> Text: ...

    def get_already_pending(self) -> Text: ...

    def get_already_owned_by_user(self) -> Text: ...

    def get_reached_limit(self) -> Text: ...

    def get_transient_error(self) -> Text: ...

    def get_too_many_updates(self) -> Text: ...

    def get_unknown_error(self) -> Text: ...

    def get_rate_limited(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddSecondaryEmailResult_validator: bv.Validator = ...

class AddSecondaryEmailsArg(bb.Struct):
    def __init__(self,
                 new_secondary_emails: List[UserSecondaryEmailsArg] = ...) -> None: ...
    new_secondary_emails: bb.Attribute[List[UserSecondaryEmailsArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddSecondaryEmailsArg_validator: bv.Validator = ...

class AddSecondaryEmailsError(bb.Union):
    secondary_emails_disabled: AddSecondaryEmailsError = ...
    too_many_emails: AddSecondaryEmailsError = ...
    other: AddSecondaryEmailsError = ...

    def is_secondary_emails_disabled(self) -> bool: ...

    def is_too_many_emails(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddSecondaryEmailsError_validator: bv.Validator = ...

class AddSecondaryEmailsResult(bb.Struct):
    def __init__(self,
                 results: List[UserAddResult] = ...) -> None: ...
    results: bb.Attribute[List[UserAddResult]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddSecondaryEmailsResult_validator: bv.Validator = ...

class AdminTier(bb.Union):
    team_admin: AdminTier = ...
    user_management_admin: AdminTier = ...
    support_admin: AdminTier = ...
    member_only: AdminTier = ...

    def is_team_admin(self) -> bool: ...

    def is_user_management_admin(self) -> bool: ...

    def is_support_admin(self) -> bool: ...

    def is_member_only(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AdminTier_validator: bv.Validator = ...

class ApiApp(bb.Struct):
    def __init__(self,
                 app_id: Text = ...,
                 app_name: Text = ...,
                 is_app_folder: bool = ...,
                 publisher: Optional[Text] = ...,
                 publisher_url: Optional[Text] = ...,
                 linked: Optional[datetime.datetime] = ...) -> None: ...
    app_id: bb.Attribute[Text] = ...
    app_name: bb.Attribute[Text] = ...
    is_app_folder: bb.Attribute[bool] = ...
    publisher: bb.Attribute[Optional[Text]] = ...
    publisher_url: bb.Attribute[Optional[Text]] = ...
    linked: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ApiApp_validator: bv.Validator = ...

class BaseDfbReport(bb.Struct):
    def __init__(self,
                 start_date: Text = ...) -> None: ...
    start_date: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

BaseDfbReport_validator: bv.Validator = ...

class BaseTeamFolderError(bb.Union):
    other: BaseTeamFolderError = ...

    def is_access_error(self) -> bool: ...

    def is_status_error(self) -> bool: ...

    def is_team_shared_dropbox_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: TeamFolderAccessError) -> BaseTeamFolderError: ...

    @classmethod
    def status_error(cls, val: TeamFolderInvalidStatusError) -> BaseTeamFolderError: ...

    @classmethod
    def team_shared_dropbox_error(cls, val: TeamFolderTeamSharedDropboxError) -> BaseTeamFolderError: ...

    def get_access_error(self) -> TeamFolderAccessError: ...

    def get_status_error(self) -> TeamFolderInvalidStatusError: ...

    def get_team_shared_dropbox_error(self) -> TeamFolderTeamSharedDropboxError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

BaseTeamFolderError_validator: bv.Validator = ...

class CustomQuotaError(bb.Union):
    too_many_users: CustomQuotaError = ...
    other: CustomQuotaError = ...

    def is_too_many_users(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CustomQuotaError_validator: bv.Validator = ...

class CustomQuotaResult(bb.Union):
    other: CustomQuotaResult = ...

    def is_success(self) -> bool: ...

    def is_invalid_user(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: UserCustomQuotaResult) -> CustomQuotaResult: ...

    @classmethod
    def invalid_user(cls, val: UserSelectorArg) -> CustomQuotaResult: ...

    def get_success(self) -> UserCustomQuotaResult: ...

    def get_invalid_user(self) -> UserSelectorArg: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CustomQuotaResult_validator: bv.Validator = ...

class CustomQuotaUsersArg(bb.Struct):
    def __init__(self,
                 users: List[UserSelectorArg] = ...) -> None: ...
    users: bb.Attribute[List[UserSelectorArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CustomQuotaUsersArg_validator: bv.Validator = ...

class DateRange(bb.Struct):
    def __init__(self,
                 start_date: Optional[datetime.datetime] = ...,
                 end_date: Optional[datetime.datetime] = ...) -> None: ...
    start_date: bb.Attribute[Optional[datetime.datetime]] = ...
    end_date: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DateRange_validator: bv.Validator = ...

class DateRangeError(bb.Union):
    other: DateRangeError = ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DateRangeError_validator: bv.Validator = ...

class DeleteSecondaryEmailResult(bb.Union):
    other: DeleteSecondaryEmailResult = ...

    def is_success(self) -> bool: ...

    def is_not_found(self) -> bool: ...

    def is_cannot_remove_primary(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: Text) -> DeleteSecondaryEmailResult: ...

    @classmethod
    def not_found(cls, val: Text) -> DeleteSecondaryEmailResult: ...

    @classmethod
    def cannot_remove_primary(cls, val: Text) -> DeleteSecondaryEmailResult: ...

    def get_success(self) -> Text: ...

    def get_not_found(self) -> Text: ...

    def get_cannot_remove_primary(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteSecondaryEmailResult_validator: bv.Validator = ...

class DeleteSecondaryEmailsArg(bb.Struct):
    def __init__(self,
                 emails_to_delete: List[UserSecondaryEmailsArg] = ...) -> None: ...
    emails_to_delete: bb.Attribute[List[UserSecondaryEmailsArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteSecondaryEmailsArg_validator: bv.Validator = ...

class DeleteSecondaryEmailsResult(bb.Struct):
    def __init__(self,
                 results: List[UserDeleteResult] = ...) -> None: ...
    results: bb.Attribute[List[UserDeleteResult]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteSecondaryEmailsResult_validator: bv.Validator = ...

class DesktopClientSession(DeviceSession):
    def __init__(self,
                 session_id: Text = ...,
                 host_name: Text = ...,
                 client_type: DesktopPlatform = ...,
                 client_version: Text = ...,
                 platform: Text = ...,
                 is_delete_on_unlink_supported: bool = ...,
                 ip_address: Optional[Text] = ...,
                 country: Optional[Text] = ...,
                 created: Optional[datetime.datetime] = ...,
                 updated: Optional[datetime.datetime] = ...) -> None: ...
    session_id: bb.Attribute[Text] = ...
    host_name: bb.Attribute[Text] = ...
    client_type: bb.Attribute[DesktopPlatform] = ...
    client_version: bb.Attribute[Text] = ...
    platform: bb.Attribute[Text] = ...
    is_delete_on_unlink_supported: bb.Attribute[bool] = ...
    ip_address: bb.Attribute[Optional[Text]] = ...
    country: bb.Attribute[Optional[Text]] = ...
    created: bb.Attribute[Optional[datetime.datetime]] = ...
    updated: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DesktopClientSession_validator: bv.Validator = ...

class DesktopPlatform(bb.Union):
    windows: DesktopPlatform = ...
    mac: DesktopPlatform = ...
    linux: DesktopPlatform = ...
    other: DesktopPlatform = ...

    def is_windows(self) -> bool: ...

    def is_mac(self) -> bool: ...

    def is_linux(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DesktopPlatform_validator: bv.Validator = ...

class DeviceSessionArg(bb.Struct):
    def __init__(self,
                 session_id: Text = ...,
                 team_member_id: Text = ...) -> None: ...
    session_id: bb.Attribute[Text] = ...
    team_member_id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeviceSessionArg_validator: bv.Validator = ...

class DevicesActive(bb.Struct):
    def __init__(self,
                 windows: List[Optional[int]] = ...,
                 macos: List[Optional[int]] = ...,
                 linux: List[Optional[int]] = ...,
                 ios: List[Optional[int]] = ...,
                 android: List[Optional[int]] = ...,
                 other: List[Optional[int]] = ...,
                 total: List[Optional[int]] = ...) -> None: ...
    windows: bb.Attribute[List[Optional[int]]] = ...
    macos: bb.Attribute[List[Optional[int]]] = ...
    linux: bb.Attribute[List[Optional[int]]] = ...
    ios: bb.Attribute[List[Optional[int]]] = ...
    android: bb.Attribute[List[Optional[int]]] = ...
    other: bb.Attribute[List[Optional[int]]] = ...
    total: bb.Attribute[List[Optional[int]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DevicesActive_validator: bv.Validator = ...

class ExcludedUsersListArg(bb.Struct):
    def __init__(self,
                 limit: Optional[int] = ...) -> None: ...
    limit: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExcludedUsersListArg_validator: bv.Validator = ...

class ExcludedUsersListContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExcludedUsersListContinueArg_validator: bv.Validator = ...

class ExcludedUsersListContinueError(bb.Union):
    invalid_cursor: ExcludedUsersListContinueError = ...
    other: ExcludedUsersListContinueError = ...

    def is_invalid_cursor(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExcludedUsersListContinueError_validator: bv.Validator = ...

class ExcludedUsersListError(bb.Union):
    list_error: ExcludedUsersListError = ...
    other: ExcludedUsersListError = ...

    def is_list_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExcludedUsersListError_validator: bv.Validator = ...

class ExcludedUsersListResult(bb.Struct):
    def __init__(self,
                 users: List[MemberProfile] = ...,
                 has_more: bool = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    users: bb.Attribute[List[MemberProfile]] = ...
    has_more: bb.Attribute[bool] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExcludedUsersListResult_validator: bv.Validator = ...

class ExcludedUsersUpdateArg(bb.Struct):
    def __init__(self,
                 users: Optional[List[UserSelectorArg]] = ...) -> None: ...
    users: bb.Attribute[Optional[List[UserSelectorArg]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExcludedUsersUpdateArg_validator: bv.Validator = ...

class ExcludedUsersUpdateError(bb.Union):
    users_not_in_team: ExcludedUsersUpdateError = ...
    too_many_users: ExcludedUsersUpdateError = ...
    other: ExcludedUsersUpdateError = ...

    def is_users_not_in_team(self) -> bool: ...

    def is_too_many_users(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExcludedUsersUpdateError_validator: bv.Validator = ...

class ExcludedUsersUpdateResult(bb.Struct):
    def __init__(self,
                 status: ExcludedUsersUpdateStatus = ...) -> None: ...
    status: bb.Attribute[ExcludedUsersUpdateStatus] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExcludedUsersUpdateResult_validator: bv.Validator = ...

class ExcludedUsersUpdateStatus(bb.Union):
    success: ExcludedUsersUpdateStatus = ...
    other: ExcludedUsersUpdateStatus = ...

    def is_success(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExcludedUsersUpdateStatus_validator: bv.Validator = ...

class Feature(bb.Union):
    upload_api_rate_limit: Feature = ...
    has_team_shared_dropbox: Feature = ...
    has_team_file_events: Feature = ...
    has_team_selective_sync: Feature = ...
    other: Feature = ...

    def is_upload_api_rate_limit(self) -> bool: ...

    def is_has_team_shared_dropbox(self) -> bool: ...

    def is_has_team_file_events(self) -> bool: ...

    def is_has_team_selective_sync(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

Feature_validator: bv.Validator = ...

class FeatureValue(bb.Union):
    other: FeatureValue = ...

    def is_upload_api_rate_limit(self) -> bool: ...

    def is_has_team_shared_dropbox(self) -> bool: ...

    def is_has_team_file_events(self) -> bool: ...

    def is_has_team_selective_sync(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def upload_api_rate_limit(cls, val: UploadApiRateLimitValue) -> FeatureValue: ...

    @classmethod
    def has_team_shared_dropbox(cls, val: HasTeamSharedDropboxValue) -> FeatureValue: ...

    @classmethod
    def has_team_file_events(cls, val: HasTeamFileEventsValue) -> FeatureValue: ...

    @classmethod
    def has_team_selective_sync(cls, val: HasTeamSelectiveSyncValue) -> FeatureValue: ...

    def get_upload_api_rate_limit(self) -> UploadApiRateLimitValue: ...

    def get_has_team_shared_dropbox(self) -> HasTeamSharedDropboxValue: ...

    def get_has_team_file_events(self) -> HasTeamFileEventsValue: ...

    def get_has_team_selective_sync(self) -> HasTeamSelectiveSyncValue: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FeatureValue_validator: bv.Validator = ...

class FeaturesGetValuesBatchArg(bb.Struct):
    def __init__(self,
                 features: List[Feature] = ...) -> None: ...
    features: bb.Attribute[List[Feature]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FeaturesGetValuesBatchArg_validator: bv.Validator = ...

class FeaturesGetValuesBatchError(bb.Union):
    empty_features_list: FeaturesGetValuesBatchError = ...
    other: FeaturesGetValuesBatchError = ...

    def is_empty_features_list(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FeaturesGetValuesBatchError_validator: bv.Validator = ...

class FeaturesGetValuesBatchResult(bb.Struct):
    def __init__(self,
                 values: List[FeatureValue] = ...) -> None: ...
    values: bb.Attribute[List[FeatureValue]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FeaturesGetValuesBatchResult_validator: bv.Validator = ...

class GetActivityReport(BaseDfbReport):
    def __init__(self,
                 start_date: Text = ...,
                 adds: List[Optional[int]] = ...,
                 edits: List[Optional[int]] = ...,
                 deletes: List[Optional[int]] = ...,
                 active_users_28_day: List[Optional[int]] = ...,
                 active_users_7_day: List[Optional[int]] = ...,
                 active_users_1_day: List[Optional[int]] = ...,
                 active_shared_folders_28_day: List[Optional[int]] = ...,
                 active_shared_folders_7_day: List[Optional[int]] = ...,
                 active_shared_folders_1_day: List[Optional[int]] = ...,
                 shared_links_created: List[Optional[int]] = ...,
                 shared_links_viewed_by_team: List[Optional[int]] = ...,
                 shared_links_viewed_by_outside_user: List[Optional[int]] = ...,
                 shared_links_viewed_by_not_logged_in: List[Optional[int]] = ...,
                 shared_links_viewed_total: List[Optional[int]] = ...) -> None: ...
    start_date: bb.Attribute[Text] = ...
    adds: bb.Attribute[List[Optional[int]]] = ...
    edits: bb.Attribute[List[Optional[int]]] = ...
    deletes: bb.Attribute[List[Optional[int]]] = ...
    active_users_28_day: bb.Attribute[List[Optional[int]]] = ...
    active_users_7_day: bb.Attribute[List[Optional[int]]] = ...
    active_users_1_day: bb.Attribute[List[Optional[int]]] = ...
    active_shared_folders_28_day: bb.Attribute[List[Optional[int]]] = ...
    active_shared_folders_7_day: bb.Attribute[List[Optional[int]]] = ...
    active_shared_folders_1_day: bb.Attribute[List[Optional[int]]] = ...
    shared_links_created: bb.Attribute[List[Optional[int]]] = ...
    shared_links_viewed_by_team: bb.Attribute[List[Optional[int]]] = ...
    shared_links_viewed_by_outside_user: bb.Attribute[List[Optional[int]]] = ...
    shared_links_viewed_by_not_logged_in: bb.Attribute[List[Optional[int]]] = ...
    shared_links_viewed_total: bb.Attribute[List[Optional[int]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetActivityReport_validator: bv.Validator = ...

class GetDevicesReport(BaseDfbReport):
    def __init__(self,
                 start_date: Text = ...,
                 active_1_day: DevicesActive = ...,
                 active_7_day: DevicesActive = ...,
                 active_28_day: DevicesActive = ...) -> None: ...
    start_date: bb.Attribute[Text] = ...
    active_1_day: bb.Attribute[DevicesActive] = ...
    active_7_day: bb.Attribute[DevicesActive] = ...
    active_28_day: bb.Attribute[DevicesActive] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetDevicesReport_validator: bv.Validator = ...

class GetMembershipReport(BaseDfbReport):
    def __init__(self,
                 start_date: Text = ...,
                 team_size: List[Optional[int]] = ...,
                 pending_invites: List[Optional[int]] = ...,
                 members_joined: List[Optional[int]] = ...,
                 suspended_members: List[Optional[int]] = ...,
                 licenses: List[Optional[int]] = ...) -> None: ...
    start_date: bb.Attribute[Text] = ...
    team_size: bb.Attribute[List[Optional[int]]] = ...
    pending_invites: bb.Attribute[List[Optional[int]]] = ...
    members_joined: bb.Attribute[List[Optional[int]]] = ...
    suspended_members: bb.Attribute[List[Optional[int]]] = ...
    licenses: bb.Attribute[List[Optional[int]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetMembershipReport_validator: bv.Validator = ...

class GetStorageReport(BaseDfbReport):
    def __init__(self,
                 start_date: Text = ...,
                 total_usage: List[Optional[int]] = ...,
                 shared_usage: List[Optional[int]] = ...,
                 unshared_usage: List[Optional[int]] = ...,
                 shared_folders: List[Optional[int]] = ...,
                 member_storage_map: List[List[StorageBucket]] = ...) -> None: ...
    start_date: bb.Attribute[Text] = ...
    total_usage: bb.Attribute[List[Optional[int]]] = ...
    shared_usage: bb.Attribute[List[Optional[int]]] = ...
    unshared_usage: bb.Attribute[List[Optional[int]]] = ...
    shared_folders: bb.Attribute[List[Optional[int]]] = ...
    member_storage_map: bb.Attribute[List[List[StorageBucket]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetStorageReport_validator: bv.Validator = ...

class GroupAccessType(bb.Union):
    member: GroupAccessType = ...
    owner: GroupAccessType = ...

    def is_member(self) -> bool: ...

    def is_owner(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupAccessType_validator: bv.Validator = ...

class GroupCreateArg(bb.Struct):
    def __init__(self,
                 group_name: Text = ...,
                 add_creator_as_owner: Optional[bool] = ...,
                 group_external_id: Optional[Text] = ...,
                 group_management_type: Optional[team_common.GroupManagementType] = ...) -> None: ...
    group_name: bb.Attribute[Text] = ...
    add_creator_as_owner: bb.Attribute[bool] = ...
    group_external_id: bb.Attribute[Optional[Text]] = ...
    group_management_type: bb.Attribute[Optional[team_common.GroupManagementType]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupCreateArg_validator: bv.Validator = ...

class GroupCreateError(bb.Union):
    group_name_already_used: GroupCreateError = ...
    group_name_invalid: GroupCreateError = ...
    external_id_already_in_use: GroupCreateError = ...
    system_managed_group_disallowed: GroupCreateError = ...
    other: GroupCreateError = ...

    def is_group_name_already_used(self) -> bool: ...

    def is_group_name_invalid(self) -> bool: ...

    def is_external_id_already_in_use(self) -> bool: ...

    def is_system_managed_group_disallowed(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupCreateError_validator: bv.Validator = ...

class GroupSelectorError(bb.Union):
    group_not_found: GroupSelectorError = ...
    other: GroupSelectorError = ...

    def is_group_not_found(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupSelectorError_validator: bv.Validator = ...

class GroupSelectorWithTeamGroupError(GroupSelectorError):
    system_managed_group_disallowed: GroupSelectorWithTeamGroupError = ...

    def is_system_managed_group_disallowed(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupSelectorWithTeamGroupError_validator: bv.Validator = ...

class GroupDeleteError(GroupSelectorWithTeamGroupError):
    group_already_deleted: GroupDeleteError = ...

    def is_group_already_deleted(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupDeleteError_validator: bv.Validator = ...

class GroupFullInfo(team_common.GroupSummary):
    def __init__(self,
                 group_name: Text = ...,
                 group_id: Text = ...,
                 group_management_type: team_common.GroupManagementType = ...,
                 created: int = ...,
                 group_external_id: Optional[Text] = ...,
                 member_count: Optional[int] = ...,
                 members: Optional[List[GroupMemberInfo]] = ...) -> None: ...
    group_name: bb.Attribute[Text] = ...
    group_id: bb.Attribute[Text] = ...
    group_management_type: bb.Attribute[team_common.GroupManagementType] = ...
    created: bb.Attribute[int] = ...
    group_external_id: bb.Attribute[Optional[Text]] = ...
    member_count: bb.Attribute[Optional[int]] = ...
    members: bb.Attribute[Optional[List[GroupMemberInfo]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupFullInfo_validator: bv.Validator = ...

class GroupMemberInfo(bb.Struct):
    def __init__(self,
                 profile: MemberProfile = ...,
                 access_type: GroupAccessType = ...) -> None: ...
    profile: bb.Attribute[MemberProfile] = ...
    access_type: bb.Attribute[GroupAccessType] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMemberInfo_validator: bv.Validator = ...

class GroupMemberSelector(bb.Struct):
    def __init__(self,
                 group: GroupSelector = ...,
                 user: UserSelectorArg = ...) -> None: ...
    group: bb.Attribute[GroupSelector] = ...
    user: bb.Attribute[UserSelectorArg] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMemberSelector_validator: bv.Validator = ...

class GroupMemberSelectorError(GroupSelectorWithTeamGroupError):
    member_not_in_group: GroupMemberSelectorError = ...

    def is_member_not_in_group(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMemberSelectorError_validator: bv.Validator = ...

class GroupMemberSetAccessTypeError(GroupMemberSelectorError):
    user_cannot_be_manager_of_company_managed_group: GroupMemberSetAccessTypeError = ...

    def is_user_cannot_be_manager_of_company_managed_group(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMemberSetAccessTypeError_validator: bv.Validator = ...

class IncludeMembersArg(bb.Struct):
    def __init__(self,
                 return_members: Optional[bool] = ...) -> None: ...
    return_members: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

IncludeMembersArg_validator: bv.Validator = ...

class GroupMembersAddArg(IncludeMembersArg):
    def __init__(self,
                 group: GroupSelector = ...,
                 members: List[MemberAccess] = ...,
                 return_members: Optional[bool] = ...) -> None: ...
    group: bb.Attribute[GroupSelector] = ...
    members: bb.Attribute[List[MemberAccess]] = ...
    return_members: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMembersAddArg_validator: bv.Validator = ...

class GroupMembersAddError(GroupSelectorWithTeamGroupError):
    duplicate_user: GroupMembersAddError = ...
    group_not_in_team: GroupMembersAddError = ...
    user_must_be_active_to_be_owner: GroupMembersAddError = ...

    def is_duplicate_user(self) -> bool: ...

    def is_group_not_in_team(self) -> bool: ...

    def is_members_not_in_team(self) -> bool: ...

    def is_users_not_found(self) -> bool: ...

    def is_user_must_be_active_to_be_owner(self) -> bool: ...

    def is_user_cannot_be_manager_of_company_managed_group(self) -> bool: ...

    @classmethod
    def members_not_in_team(cls, val: List[Text]) -> GroupMembersAddError: ...

    @classmethod
    def users_not_found(cls, val: List[Text]) -> GroupMembersAddError: ...

    @classmethod
    def user_cannot_be_manager_of_company_managed_group(cls, val: List[Text]) -> GroupMembersAddError: ...

    def get_members_not_in_team(self) -> List[Text]: ...

    def get_users_not_found(self) -> List[Text]: ...

    def get_user_cannot_be_manager_of_company_managed_group(self) -> List[Text]: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMembersAddError_validator: bv.Validator = ...

class GroupMembersChangeResult(bb.Struct):
    def __init__(self,
                 group_info: GroupFullInfo = ...,
                 async_job_id: Text = ...) -> None: ...
    group_info: bb.Attribute[GroupFullInfo] = ...
    async_job_id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMembersChangeResult_validator: bv.Validator = ...

class GroupMembersRemoveArg(IncludeMembersArg):
    def __init__(self,
                 group: GroupSelector = ...,
                 users: List[UserSelectorArg] = ...,
                 return_members: Optional[bool] = ...) -> None: ...
    group: bb.Attribute[GroupSelector] = ...
    users: bb.Attribute[List[UserSelectorArg]] = ...
    return_members: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMembersRemoveArg_validator: bv.Validator = ...

class GroupMembersSelectorError(GroupSelectorWithTeamGroupError):
    member_not_in_group: GroupMembersSelectorError = ...

    def is_member_not_in_group(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMembersSelectorError_validator: bv.Validator = ...

class GroupMembersRemoveError(GroupMembersSelectorError):
    group_not_in_team: GroupMembersRemoveError = ...

    def is_group_not_in_team(self) -> bool: ...

    def is_members_not_in_team(self) -> bool: ...

    def is_users_not_found(self) -> bool: ...

    @classmethod
    def members_not_in_team(cls, val: List[Text]) -> GroupMembersRemoveError: ...

    @classmethod
    def users_not_found(cls, val: List[Text]) -> GroupMembersRemoveError: ...

    def get_members_not_in_team(self) -> List[Text]: ...

    def get_users_not_found(self) -> List[Text]: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMembersRemoveError_validator: bv.Validator = ...

class GroupMembersSelector(bb.Struct):
    def __init__(self,
                 group: GroupSelector = ...,
                 users: UsersSelectorArg = ...) -> None: ...
    group: bb.Attribute[GroupSelector] = ...
    users: bb.Attribute[UsersSelectorArg] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMembersSelector_validator: bv.Validator = ...

class GroupMembersSetAccessTypeArg(GroupMemberSelector):
    def __init__(self,
                 group: GroupSelector = ...,
                 user: UserSelectorArg = ...,
                 access_type: GroupAccessType = ...,
                 return_members: Optional[bool] = ...) -> None: ...
    group: bb.Attribute[GroupSelector] = ...
    user: bb.Attribute[UserSelectorArg] = ...
    access_type: bb.Attribute[GroupAccessType] = ...
    return_members: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMembersSetAccessTypeArg_validator: bv.Validator = ...

class GroupSelector(bb.Union):
    def is_group_id(self) -> bool: ...

    def is_group_external_id(self) -> bool: ...

    @classmethod
    def group_id(cls, val: Text) -> GroupSelector: ...

    @classmethod
    def group_external_id(cls, val: Text) -> GroupSelector: ...

    def get_group_id(self) -> Text: ...

    def get_group_external_id(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupSelector_validator: bv.Validator = ...

class GroupUpdateArgs(IncludeMembersArg):
    def __init__(self,
                 group: GroupSelector = ...,
                 return_members: Optional[bool] = ...,
                 new_group_name: Optional[Text] = ...,
                 new_group_external_id: Optional[Text] = ...,
                 new_group_management_type: Optional[team_common.GroupManagementType] = ...) -> None: ...
    group: bb.Attribute[GroupSelector] = ...
    return_members: bb.Attribute[bool] = ...
    new_group_name: bb.Attribute[Optional[Text]] = ...
    new_group_external_id: bb.Attribute[Optional[Text]] = ...
    new_group_management_type: bb.Attribute[Optional[team_common.GroupManagementType]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupUpdateArgs_validator: bv.Validator = ...

class GroupUpdateError(GroupSelectorWithTeamGroupError):
    group_name_already_used: GroupUpdateError = ...
    group_name_invalid: GroupUpdateError = ...
    external_id_already_in_use: GroupUpdateError = ...

    def is_group_name_already_used(self) -> bool: ...

    def is_group_name_invalid(self) -> bool: ...

    def is_external_id_already_in_use(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupUpdateError_validator: bv.Validator = ...

class GroupsGetInfoError(bb.Union):
    group_not_on_team: GroupsGetInfoError = ...
    other: GroupsGetInfoError = ...

    def is_group_not_on_team(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsGetInfoError_validator: bv.Validator = ...

class GroupsGetInfoItem(bb.Union):
    def is_id_not_found(self) -> bool: ...

    def is_group_info(self) -> bool: ...

    @classmethod
    def id_not_found(cls, val: Text) -> GroupsGetInfoItem: ...

    @classmethod
    def group_info(cls, val: GroupFullInfo) -> GroupsGetInfoItem: ...

    def get_id_not_found(self) -> Text: ...

    def get_group_info(self) -> GroupFullInfo: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsGetInfoItem_validator: bv.Validator = ...

class GroupsListArg(bb.Struct):
    def __init__(self,
                 limit: Optional[int] = ...) -> None: ...
    limit: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsListArg_validator: bv.Validator = ...

class GroupsListContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsListContinueArg_validator: bv.Validator = ...

class GroupsListContinueError(bb.Union):
    invalid_cursor: GroupsListContinueError = ...
    other: GroupsListContinueError = ...

    def is_invalid_cursor(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsListContinueError_validator: bv.Validator = ...

class GroupsListResult(bb.Struct):
    def __init__(self,
                 groups: List[team_common.GroupSummary] = ...,
                 cursor: Text = ...,
                 has_more: bool = ...) -> None: ...
    groups: bb.Attribute[List[team_common.GroupSummary]] = ...
    cursor: bb.Attribute[Text] = ...
    has_more: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsListResult_validator: bv.Validator = ...

class GroupsMembersListArg(bb.Struct):
    def __init__(self,
                 group: GroupSelector = ...,
                 limit: Optional[int] = ...) -> None: ...
    group: bb.Attribute[GroupSelector] = ...
    limit: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsMembersListArg_validator: bv.Validator = ...

class GroupsMembersListContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsMembersListContinueArg_validator: bv.Validator = ...

class GroupsMembersListContinueError(bb.Union):
    invalid_cursor: GroupsMembersListContinueError = ...
    other: GroupsMembersListContinueError = ...

    def is_invalid_cursor(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsMembersListContinueError_validator: bv.Validator = ...

class GroupsMembersListResult(bb.Struct):
    def __init__(self,
                 members: List[GroupMemberInfo] = ...,
                 cursor: Text = ...,
                 has_more: bool = ...) -> None: ...
    members: bb.Attribute[List[GroupMemberInfo]] = ...
    cursor: bb.Attribute[Text] = ...
    has_more: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsMembersListResult_validator: bv.Validator = ...

class GroupsPollError(async_.PollError):
    access_denied: GroupsPollError = ...

    def is_access_denied(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsPollError_validator: bv.Validator = ...

class GroupsSelector(bb.Union):
    def is_group_ids(self) -> bool: ...

    def is_group_external_ids(self) -> bool: ...

    @classmethod
    def group_ids(cls, val: List[Text]) -> GroupsSelector: ...

    @classmethod
    def group_external_ids(cls, val: List[Text]) -> GroupsSelector: ...

    def get_group_ids(self) -> List[Text]: ...

    def get_group_external_ids(self) -> List[Text]: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupsSelector_validator: bv.Validator = ...

class HasTeamFileEventsValue(bb.Union):
    other: HasTeamFileEventsValue = ...

    def is_enabled(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def enabled(cls, val: bool) -> HasTeamFileEventsValue: ...

    def get_enabled(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

HasTeamFileEventsValue_validator: bv.Validator = ...

class HasTeamSelectiveSyncValue(bb.Union):
    other: HasTeamSelectiveSyncValue = ...

    def is_has_team_selective_sync(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def has_team_selective_sync(cls, val: bool) -> HasTeamSelectiveSyncValue: ...

    def get_has_team_selective_sync(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

HasTeamSelectiveSyncValue_validator: bv.Validator = ...

class HasTeamSharedDropboxValue(bb.Union):
    other: HasTeamSharedDropboxValue = ...

    def is_has_team_shared_dropbox(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def has_team_shared_dropbox(cls, val: bool) -> HasTeamSharedDropboxValue: ...

    def get_has_team_shared_dropbox(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

HasTeamSharedDropboxValue_validator: bv.Validator = ...

class LegalHoldHeldRevisionMetadata(bb.Struct):
    def __init__(self,
                 new_filename: Text = ...,
                 original_revision_id: Text = ...,
                 original_file_path: Text = ...,
                 server_modified: datetime.datetime = ...,
                 author_member_id: Text = ...,
                 author_member_status: TeamMemberStatus = ...,
                 author_email: Text = ...,
                 file_type: Text = ...,
                 size: int = ...,
                 content_hash: Text = ...) -> None: ...
    new_filename: bb.Attribute[Text] = ...
    original_revision_id: bb.Attribute[Text] = ...
    original_file_path: bb.Attribute[Text] = ...
    server_modified: bb.Attribute[datetime.datetime] = ...
    author_member_id: bb.Attribute[Text] = ...
    author_member_status: bb.Attribute[TeamMemberStatus] = ...
    author_email: bb.Attribute[Text] = ...
    file_type: bb.Attribute[Text] = ...
    size: bb.Attribute[int] = ...
    content_hash: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldHeldRevisionMetadata_validator: bv.Validator = ...

class LegalHoldPolicy(bb.Struct):
    def __init__(self,
                 id: Text = ...,
                 name: Text = ...,
                 members: MembersInfo = ...,
                 status: LegalHoldStatus = ...,
                 start_date: datetime.datetime = ...,
                 description: Optional[Text] = ...,
                 activation_time: Optional[datetime.datetime] = ...,
                 end_date: Optional[datetime.datetime] = ...) -> None: ...
    id: bb.Attribute[Text] = ...
    name: bb.Attribute[Text] = ...
    members: bb.Attribute[MembersInfo] = ...
    status: bb.Attribute[LegalHoldStatus] = ...
    start_date: bb.Attribute[datetime.datetime] = ...
    description: bb.Attribute[Optional[Text]] = ...
    activation_time: bb.Attribute[Optional[datetime.datetime]] = ...
    end_date: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldPolicy_validator: bv.Validator = ...

class LegalHoldStatus(bb.Union):
    active: LegalHoldStatus = ...
    released: LegalHoldStatus = ...
    activating: LegalHoldStatus = ...
    updating: LegalHoldStatus = ...
    exporting: LegalHoldStatus = ...
    releasing: LegalHoldStatus = ...
    other: LegalHoldStatus = ...

    def is_active(self) -> bool: ...

    def is_released(self) -> bool: ...

    def is_activating(self) -> bool: ...

    def is_updating(self) -> bool: ...

    def is_exporting(self) -> bool: ...

    def is_releasing(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldStatus_validator: bv.Validator = ...

class LegalHoldsError(bb.Union):
    unknown_legal_hold_error: LegalHoldsError = ...
    insufficient_permissions: LegalHoldsError = ...
    other: LegalHoldsError = ...

    def is_unknown_legal_hold_error(self) -> bool: ...

    def is_insufficient_permissions(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsError_validator: bv.Validator = ...

class LegalHoldsGetPolicyArg(bb.Struct):
    def __init__(self,
                 id: Text = ...) -> None: ...
    id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsGetPolicyArg_validator: bv.Validator = ...

class LegalHoldsGetPolicyError(LegalHoldsError):
    legal_hold_policy_not_found: LegalHoldsGetPolicyError = ...

    def is_legal_hold_policy_not_found(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsGetPolicyError_validator: bv.Validator = ...

class LegalHoldsListHeldRevisionResult(bb.Struct):
    def __init__(self,
                 entries: List[LegalHoldHeldRevisionMetadata] = ...,
                 has_more: bool = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    entries: bb.Attribute[List[LegalHoldHeldRevisionMetadata]] = ...
    has_more: bb.Attribute[bool] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsListHeldRevisionResult_validator: bv.Validator = ...

class LegalHoldsListHeldRevisionsArg(bb.Struct):
    def __init__(self,
                 id: Text = ...) -> None: ...
    id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsListHeldRevisionsArg_validator: bv.Validator = ...

class LegalHoldsListHeldRevisionsContinueArg(bb.Struct):
    def __init__(self,
                 id: Text = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    id: bb.Attribute[Text] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsListHeldRevisionsContinueArg_validator: bv.Validator = ...

class LegalHoldsListHeldRevisionsContinueError(bb.Union):
    unknown_legal_hold_error: LegalHoldsListHeldRevisionsContinueError = ...
    transient_error: LegalHoldsListHeldRevisionsContinueError = ...
    reset: LegalHoldsListHeldRevisionsContinueError = ...
    other: LegalHoldsListHeldRevisionsContinueError = ...

    def is_unknown_legal_hold_error(self) -> bool: ...

    def is_transient_error(self) -> bool: ...

    def is_reset(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsListHeldRevisionsContinueError_validator: bv.Validator = ...

class LegalHoldsListHeldRevisionsError(LegalHoldsError):
    transient_error: LegalHoldsListHeldRevisionsError = ...
    legal_hold_still_empty: LegalHoldsListHeldRevisionsError = ...
    inactive_legal_hold: LegalHoldsListHeldRevisionsError = ...

    def is_transient_error(self) -> bool: ...

    def is_legal_hold_still_empty(self) -> bool: ...

    def is_inactive_legal_hold(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsListHeldRevisionsError_validator: bv.Validator = ...

class LegalHoldsListPoliciesArg(bb.Struct):
    def __init__(self,
                 include_released: Optional[bool] = ...) -> None: ...
    include_released: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsListPoliciesArg_validator: bv.Validator = ...

class LegalHoldsListPoliciesError(LegalHoldsError):
    transient_error: LegalHoldsListPoliciesError = ...

    def is_transient_error(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsListPoliciesError_validator: bv.Validator = ...

class LegalHoldsListPoliciesResult(bb.Struct):
    def __init__(self,
                 policies: List[LegalHoldPolicy] = ...) -> None: ...
    policies: bb.Attribute[List[LegalHoldPolicy]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsListPoliciesResult_validator: bv.Validator = ...

class LegalHoldsPolicyCreateArg(bb.Struct):
    def __init__(self,
                 name: Text = ...,
                 members: List[Text] = ...,
                 description: Optional[Text] = ...,
                 start_date: Optional[datetime.datetime] = ...,
                 end_date: Optional[datetime.datetime] = ...) -> None: ...
    name: bb.Attribute[Text] = ...
    members: bb.Attribute[List[Text]] = ...
    description: bb.Attribute[Optional[Text]] = ...
    start_date: bb.Attribute[Optional[datetime.datetime]] = ...
    end_date: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsPolicyCreateArg_validator: bv.Validator = ...

class LegalHoldsPolicyCreateError(LegalHoldsError):
    start_date_is_later_than_end_date: LegalHoldsPolicyCreateError = ...
    empty_members_list: LegalHoldsPolicyCreateError = ...
    invalid_members: LegalHoldsPolicyCreateError = ...
    number_of_users_on_hold_is_greater_than_hold_limitation: LegalHoldsPolicyCreateError = ...
    transient_error: LegalHoldsPolicyCreateError = ...
    name_must_be_unique: LegalHoldsPolicyCreateError = ...
    team_exceeded_legal_hold_quota: LegalHoldsPolicyCreateError = ...
    invalid_date: LegalHoldsPolicyCreateError = ...

    def is_start_date_is_later_than_end_date(self) -> bool: ...

    def is_empty_members_list(self) -> bool: ...

    def is_invalid_members(self) -> bool: ...

    def is_number_of_users_on_hold_is_greater_than_hold_limitation(self) -> bool: ...

    def is_transient_error(self) -> bool: ...

    def is_name_must_be_unique(self) -> bool: ...

    def is_team_exceeded_legal_hold_quota(self) -> bool: ...

    def is_invalid_date(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsPolicyCreateError_validator: bv.Validator = ...

class LegalHoldsPolicyReleaseArg(bb.Struct):
    def __init__(self,
                 id: Text = ...) -> None: ...
    id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsPolicyReleaseArg_validator: bv.Validator = ...

class LegalHoldsPolicyReleaseError(LegalHoldsError):
    legal_hold_performing_another_operation: LegalHoldsPolicyReleaseError = ...
    legal_hold_already_releasing: LegalHoldsPolicyReleaseError = ...
    legal_hold_policy_not_found: LegalHoldsPolicyReleaseError = ...

    def is_legal_hold_performing_another_operation(self) -> bool: ...

    def is_legal_hold_already_releasing(self) -> bool: ...

    def is_legal_hold_policy_not_found(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsPolicyReleaseError_validator: bv.Validator = ...

class LegalHoldsPolicyUpdateArg(bb.Struct):
    def __init__(self,
                 id: Text = ...,
                 name: Optional[Text] = ...,
                 description: Optional[Text] = ...,
                 members: Optional[List[Text]] = ...) -> None: ...
    id: bb.Attribute[Text] = ...
    name: bb.Attribute[Optional[Text]] = ...
    description: bb.Attribute[Optional[Text]] = ...
    members: bb.Attribute[Optional[List[Text]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsPolicyUpdateArg_validator: bv.Validator = ...

class LegalHoldsPolicyUpdateError(LegalHoldsError):
    transient_error: LegalHoldsPolicyUpdateError = ...
    inactive_legal_hold: LegalHoldsPolicyUpdateError = ...
    legal_hold_performing_another_operation: LegalHoldsPolicyUpdateError = ...
    invalid_members: LegalHoldsPolicyUpdateError = ...
    number_of_users_on_hold_is_greater_than_hold_limitation: LegalHoldsPolicyUpdateError = ...
    empty_members_list: LegalHoldsPolicyUpdateError = ...
    name_must_be_unique: LegalHoldsPolicyUpdateError = ...
    legal_hold_policy_not_found: LegalHoldsPolicyUpdateError = ...

    def is_transient_error(self) -> bool: ...

    def is_inactive_legal_hold(self) -> bool: ...

    def is_legal_hold_performing_another_operation(self) -> bool: ...

    def is_invalid_members(self) -> bool: ...

    def is_number_of_users_on_hold_is_greater_than_hold_limitation(self) -> bool: ...

    def is_empty_members_list(self) -> bool: ...

    def is_name_must_be_unique(self) -> bool: ...

    def is_legal_hold_policy_not_found(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LegalHoldsPolicyUpdateError_validator: bv.Validator = ...

class ListMemberAppsArg(bb.Struct):
    def __init__(self,
                 team_member_id: Text = ...) -> None: ...
    team_member_id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMemberAppsArg_validator: bv.Validator = ...

class ListMemberAppsError(bb.Union):
    member_not_found: ListMemberAppsError = ...
    other: ListMemberAppsError = ...

    def is_member_not_found(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMemberAppsError_validator: bv.Validator = ...

class ListMemberAppsResult(bb.Struct):
    def __init__(self,
                 linked_api_apps: List[ApiApp] = ...) -> None: ...
    linked_api_apps: bb.Attribute[List[ApiApp]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMemberAppsResult_validator: bv.Validator = ...

class ListMemberDevicesArg(bb.Struct):
    def __init__(self,
                 team_member_id: Text = ...,
                 include_web_sessions: Optional[bool] = ...,
                 include_desktop_clients: Optional[bool] = ...,
                 include_mobile_clients: Optional[bool] = ...) -> None: ...
    team_member_id: bb.Attribute[Text] = ...
    include_web_sessions: bb.Attribute[bool] = ...
    include_desktop_clients: bb.Attribute[bool] = ...
    include_mobile_clients: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMemberDevicesArg_validator: bv.Validator = ...

class ListMemberDevicesError(bb.Union):
    member_not_found: ListMemberDevicesError = ...
    other: ListMemberDevicesError = ...

    def is_member_not_found(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMemberDevicesError_validator: bv.Validator = ...

class ListMemberDevicesResult(bb.Struct):
    def __init__(self,
                 active_web_sessions: Optional[List[ActiveWebSession]] = ...,
                 desktop_client_sessions: Optional[List[DesktopClientSession]] = ...,
                 mobile_client_sessions: Optional[List[MobileClientSession]] = ...) -> None: ...
    active_web_sessions: bb.Attribute[Optional[List[ActiveWebSession]]] = ...
    desktop_client_sessions: bb.Attribute[Optional[List[DesktopClientSession]]] = ...
    mobile_client_sessions: bb.Attribute[Optional[List[MobileClientSession]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMemberDevicesResult_validator: bv.Validator = ...

class ListMembersAppsArg(bb.Struct):
    def __init__(self,
                 cursor: Optional[Text] = ...) -> None: ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMembersAppsArg_validator: bv.Validator = ...

class ListMembersAppsError(bb.Union):
    reset: ListMembersAppsError = ...
    other: ListMembersAppsError = ...

    def is_reset(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMembersAppsError_validator: bv.Validator = ...

class ListMembersAppsResult(bb.Struct):
    def __init__(self,
                 apps: List[MemberLinkedApps] = ...,
                 has_more: bool = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    apps: bb.Attribute[List[MemberLinkedApps]] = ...
    has_more: bb.Attribute[bool] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMembersAppsResult_validator: bv.Validator = ...

class ListMembersDevicesArg(bb.Struct):
    def __init__(self,
                 cursor: Optional[Text] = ...,
                 include_web_sessions: Optional[bool] = ...,
                 include_desktop_clients: Optional[bool] = ...,
                 include_mobile_clients: Optional[bool] = ...) -> None: ...
    cursor: bb.Attribute[Optional[Text]] = ...
    include_web_sessions: bb.Attribute[bool] = ...
    include_desktop_clients: bb.Attribute[bool] = ...
    include_mobile_clients: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMembersDevicesArg_validator: bv.Validator = ...

class ListMembersDevicesError(bb.Union):
    reset: ListMembersDevicesError = ...
    other: ListMembersDevicesError = ...

    def is_reset(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMembersDevicesError_validator: bv.Validator = ...

class ListMembersDevicesResult(bb.Struct):
    def __init__(self,
                 devices: List[MemberDevices] = ...,
                 has_more: bool = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    devices: bb.Attribute[List[MemberDevices]] = ...
    has_more: bb.Attribute[bool] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListMembersDevicesResult_validator: bv.Validator = ...

class ListTeamAppsArg(bb.Struct):
    def __init__(self,
                 cursor: Optional[Text] = ...) -> None: ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListTeamAppsArg_validator: bv.Validator = ...

class ListTeamAppsError(bb.Union):
    reset: ListTeamAppsError = ...
    other: ListTeamAppsError = ...

    def is_reset(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListTeamAppsError_validator: bv.Validator = ...

class ListTeamAppsResult(bb.Struct):
    def __init__(self,
                 apps: List[MemberLinkedApps] = ...,
                 has_more: bool = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    apps: bb.Attribute[List[MemberLinkedApps]] = ...
    has_more: bb.Attribute[bool] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListTeamAppsResult_validator: bv.Validator = ...

class ListTeamDevicesArg(bb.Struct):
    def __init__(self,
                 cursor: Optional[Text] = ...,
                 include_web_sessions: Optional[bool] = ...,
                 include_desktop_clients: Optional[bool] = ...,
                 include_mobile_clients: Optional[bool] = ...) -> None: ...
    cursor: bb.Attribute[Optional[Text]] = ...
    include_web_sessions: bb.Attribute[bool] = ...
    include_desktop_clients: bb.Attribute[bool] = ...
    include_mobile_clients: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListTeamDevicesArg_validator: bv.Validator = ...

class ListTeamDevicesError(bb.Union):
    reset: ListTeamDevicesError = ...
    other: ListTeamDevicesError = ...

    def is_reset(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListTeamDevicesError_validator: bv.Validator = ...

class ListTeamDevicesResult(bb.Struct):
    def __init__(self,
                 devices: List[MemberDevices] = ...,
                 has_more: bool = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    devices: bb.Attribute[List[MemberDevices]] = ...
    has_more: bb.Attribute[bool] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListTeamDevicesResult_validator: bv.Validator = ...

class MemberAccess(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 access_type: GroupAccessType = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    access_type: bb.Attribute[GroupAccessType] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberAccess_validator: bv.Validator = ...

class MemberAddArgBase(bb.Struct):
    def __init__(self,
                 member_email: Text = ...,
                 member_given_name: Optional[Text] = ...,
                 member_surname: Optional[Text] = ...,
                 member_external_id: Optional[Text] = ...,
                 member_persistent_id: Optional[Text] = ...,
                 send_welcome_email: Optional[bool] = ...,
                 is_directory_restricted: Optional[bool] = ...) -> None: ...
    member_email: bb.Attribute[Text] = ...
    member_given_name: bb.Attribute[Optional[Text]] = ...
    member_surname: bb.Attribute[Optional[Text]] = ...
    member_external_id: bb.Attribute[Optional[Text]] = ...
    member_persistent_id: bb.Attribute[Optional[Text]] = ...
    send_welcome_email: bb.Attribute[bool] = ...
    is_directory_restricted: bb.Attribute[Optional[bool]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberAddArgBase_validator: bv.Validator = ...

class MemberAddArg(MemberAddArgBase):
    def __init__(self,
                 member_email: Text = ...,
                 member_given_name: Optional[Text] = ...,
                 member_surname: Optional[Text] = ...,
                 member_external_id: Optional[Text] = ...,
                 member_persistent_id: Optional[Text] = ...,
                 send_welcome_email: Optional[bool] = ...,
                 is_directory_restricted: Optional[bool] = ...,
                 role: Optional[AdminTier] = ...) -> None: ...
    member_email: bb.Attribute[Text] = ...
    member_given_name: bb.Attribute[Optional[Text]] = ...
    member_surname: bb.Attribute[Optional[Text]] = ...
    member_external_id: bb.Attribute[Optional[Text]] = ...
    member_persistent_id: bb.Attribute[Optional[Text]] = ...
    send_welcome_email: bb.Attribute[bool] = ...
    is_directory_restricted: bb.Attribute[Optional[bool]] = ...
    role: bb.Attribute[AdminTier] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberAddArg_validator: bv.Validator = ...

class MemberAddResultBase(bb.Union):
    def is_team_license_limit(self) -> bool: ...

    def is_free_team_member_limit_reached(self) -> bool: ...

    def is_user_already_on_team(self) -> bool: ...

    def is_user_on_another_team(self) -> bool: ...

    def is_user_already_paired(self) -> bool: ...

    def is_user_migration_failed(self) -> bool: ...

    def is_duplicate_external_member_id(self) -> bool: ...

    def is_duplicate_member_persistent_id(self) -> bool: ...

    def is_persistent_id_disabled(self) -> bool: ...

    def is_user_creation_failed(self) -> bool: ...

    @classmethod
    def team_license_limit(cls, val: Text) -> MemberAddResultBase: ...

    @classmethod
    def free_team_member_limit_reached(cls, val: Text) -> MemberAddResultBase: ...

    @classmethod
    def user_already_on_team(cls, val: Text) -> MemberAddResultBase: ...

    @classmethod
    def user_on_another_team(cls, val: Text) -> MemberAddResultBase: ...

    @classmethod
    def user_already_paired(cls, val: Text) -> MemberAddResultBase: ...

    @classmethod
    def user_migration_failed(cls, val: Text) -> MemberAddResultBase: ...

    @classmethod
    def duplicate_external_member_id(cls, val: Text) -> MemberAddResultBase: ...

    @classmethod
    def duplicate_member_persistent_id(cls, val: Text) -> MemberAddResultBase: ...

    @classmethod
    def persistent_id_disabled(cls, val: Text) -> MemberAddResultBase: ...

    @classmethod
    def user_creation_failed(cls, val: Text) -> MemberAddResultBase: ...

    def get_team_license_limit(self) -> Text: ...

    def get_free_team_member_limit_reached(self) -> Text: ...

    def get_user_already_on_team(self) -> Text: ...

    def get_user_on_another_team(self) -> Text: ...

    def get_user_already_paired(self) -> Text: ...

    def get_user_migration_failed(self) -> Text: ...

    def get_duplicate_external_member_id(self) -> Text: ...

    def get_duplicate_member_persistent_id(self) -> Text: ...

    def get_persistent_id_disabled(self) -> Text: ...

    def get_user_creation_failed(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberAddResultBase_validator: bv.Validator = ...

class MemberAddResult(MemberAddResultBase):
    def is_success(self) -> bool: ...

    @classmethod
    def success(cls, val: TeamMemberInfo) -> MemberAddResult: ...

    def get_success(self) -> TeamMemberInfo: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberAddResult_validator: bv.Validator = ...

class MemberAddV2Arg(MemberAddArgBase):
    def __init__(self,
                 member_email: Text = ...,
                 member_given_name: Optional[Text] = ...,
                 member_surname: Optional[Text] = ...,
                 member_external_id: Optional[Text] = ...,
                 member_persistent_id: Optional[Text] = ...,
                 send_welcome_email: Optional[bool] = ...,
                 is_directory_restricted: Optional[bool] = ...,
                 role_ids: Optional[List[Text]] = ...) -> None: ...
    member_email: bb.Attribute[Text] = ...
    member_given_name: bb.Attribute[Optional[Text]] = ...
    member_surname: bb.Attribute[Optional[Text]] = ...
    member_external_id: bb.Attribute[Optional[Text]] = ...
    member_persistent_id: bb.Attribute[Optional[Text]] = ...
    send_welcome_email: bb.Attribute[bool] = ...
    is_directory_restricted: bb.Attribute[Optional[bool]] = ...
    role_ids: bb.Attribute[Optional[List[Text]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberAddV2Arg_validator: bv.Validator = ...

class MemberAddV2Result(MemberAddResultBase):
    other: MemberAddV2Result = ...

    def is_success(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: TeamMemberInfoV2) -> MemberAddV2Result: ...

    def get_success(self) -> TeamMemberInfoV2: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberAddV2Result_validator: bv.Validator = ...

class MemberDevices(bb.Struct):
    def __init__(self,
                 team_member_id: Text = ...,
                 web_sessions: Optional[List[ActiveWebSession]] = ...,
                 desktop_clients: Optional[List[DesktopClientSession]] = ...,
                 mobile_clients: Optional[List[MobileClientSession]] = ...) -> None: ...
    team_member_id: bb.Attribute[Text] = ...
    web_sessions: bb.Attribute[Optional[List[ActiveWebSession]]] = ...
    desktop_clients: bb.Attribute[Optional[List[DesktopClientSession]]] = ...
    mobile_clients: bb.Attribute[Optional[List[MobileClientSession]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberDevices_validator: bv.Validator = ...

class MemberLinkedApps(bb.Struct):
    def __init__(self,
                 team_member_id: Text = ...,
                 linked_api_apps: List[ApiApp] = ...) -> None: ...
    team_member_id: bb.Attribute[Text] = ...
    linked_api_apps: bb.Attribute[List[ApiApp]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberLinkedApps_validator: bv.Validator = ...

class MemberProfile(bb.Struct):
    def __init__(self,
                 team_member_id: Text = ...,
                 email: Text = ...,
                 email_verified: bool = ...,
                 status: TeamMemberStatus = ...,
                 name: users.Name = ...,
                 membership_type: TeamMembershipType = ...,
                 external_id: Optional[Text] = ...,
                 account_id: Optional[Text] = ...,
                 secondary_emails: Optional[List[secondary_emails.SecondaryEmail]] = ...,
                 invited_on: Optional[datetime.datetime] = ...,
                 joined_on: Optional[datetime.datetime] = ...,
                 suspended_on: Optional[datetime.datetime] = ...,
                 persistent_id: Optional[Text] = ...,
                 is_directory_restricted: Optional[bool] = ...,
                 profile_photo_url: Optional[Text] = ...) -> None: ...
    team_member_id: bb.Attribute[Text] = ...
    email: bb.Attribute[Text] = ...
    email_verified: bb.Attribute[bool] = ...
    status: bb.Attribute[TeamMemberStatus] = ...
    name: bb.Attribute[users.Name] = ...
    membership_type: bb.Attribute[TeamMembershipType] = ...
    external_id: bb.Attribute[Optional[Text]] = ...
    account_id: bb.Attribute[Optional[Text]] = ...
    secondary_emails: bb.Attribute[Optional[List[secondary_emails.SecondaryEmail]]] = ...
    invited_on: bb.Attribute[Optional[datetime.datetime]] = ...
    joined_on: bb.Attribute[Optional[datetime.datetime]] = ...
    suspended_on: bb.Attribute[Optional[datetime.datetime]] = ...
    persistent_id: bb.Attribute[Optional[Text]] = ...
    is_directory_restricted: bb.Attribute[Optional[bool]] = ...
    profile_photo_url: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberProfile_validator: bv.Validator = ...

class UserSelectorError(bb.Union):
    user_not_found: UserSelectorError = ...

    def is_user_not_found(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserSelectorError_validator: bv.Validator = ...

class MemberSelectorError(UserSelectorError):
    user_not_in_team: MemberSelectorError = ...

    def is_user_not_in_team(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberSelectorError_validator: bv.Validator = ...

class MembersAddArgBase(bb.Struct):
    def __init__(self,
                 force_async: Optional[bool] = ...) -> None: ...
    force_async: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersAddArgBase_validator: bv.Validator = ...

class MembersAddArg(MembersAddArgBase):
    def __init__(self,
                 new_members: List[MemberAddArg] = ...,
                 force_async: Optional[bool] = ...) -> None: ...
    new_members: bb.Attribute[List[MemberAddArg]] = ...
    force_async: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersAddArg_validator: bv.Validator = ...

class MembersAddJobStatus(async_.PollResultBase):
    def is_complete(self) -> bool: ...

    def is_failed(self) -> bool: ...

    @classmethod
    def complete(cls, val: List[MemberAddResult]) -> MembersAddJobStatus: ...

    @classmethod
    def failed(cls, val: Text) -> MembersAddJobStatus: ...

    def get_complete(self) -> List[MemberAddResult]: ...

    def get_failed(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersAddJobStatus_validator: bv.Validator = ...

class MembersAddJobStatusV2Result(async_.PollResultBase):
    other: MembersAddJobStatusV2Result = ...

    def is_complete(self) -> bool: ...

    def is_failed(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def complete(cls, val: List[MemberAddV2Result]) -> MembersAddJobStatusV2Result: ...

    @classmethod
    def failed(cls, val: Text) -> MembersAddJobStatusV2Result: ...

    def get_complete(self) -> List[MemberAddV2Result]: ...

    def get_failed(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersAddJobStatusV2Result_validator: bv.Validator = ...

class MembersAddLaunch(async_.LaunchResultBase):
    def is_complete(self) -> bool: ...

    @classmethod
    def complete(cls, val: List[MemberAddResult]) -> MembersAddLaunch: ...

    def get_complete(self) -> List[MemberAddResult]: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersAddLaunch_validator: bv.Validator = ...

class MembersAddLaunchV2Result(async_.LaunchResultBase):
    other: MembersAddLaunchV2Result = ...

    def is_complete(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def complete(cls, val: List[MemberAddV2Result]) -> MembersAddLaunchV2Result: ...

    def get_complete(self) -> List[MemberAddV2Result]: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersAddLaunchV2Result_validator: bv.Validator = ...

class MembersAddV2Arg(MembersAddArgBase):
    def __init__(self,
                 new_members: List[MemberAddV2Arg] = ...,
                 force_async: Optional[bool] = ...) -> None: ...
    new_members: bb.Attribute[List[MemberAddV2Arg]] = ...
    force_async: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersAddV2Arg_validator: bv.Validator = ...

class MembersDeactivateBaseArg(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersDeactivateBaseArg_validator: bv.Validator = ...

class MembersDataTransferArg(MembersDeactivateBaseArg):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 transfer_dest_id: UserSelectorArg = ...,
                 transfer_admin_id: UserSelectorArg = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    transfer_dest_id: bb.Attribute[UserSelectorArg] = ...
    transfer_admin_id: bb.Attribute[UserSelectorArg] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersDataTransferArg_validator: bv.Validator = ...

class MembersDeactivateArg(MembersDeactivateBaseArg):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 wipe_data: Optional[bool] = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    wipe_data: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersDeactivateArg_validator: bv.Validator = ...

class MembersDeactivateError(UserSelectorError):
    user_not_in_team: MembersDeactivateError = ...
    other: MembersDeactivateError = ...

    def is_user_not_in_team(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersDeactivateError_validator: bv.Validator = ...

class MembersDeleteProfilePhotoArg(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersDeleteProfilePhotoArg_validator: bv.Validator = ...

class MembersDeleteProfilePhotoError(MemberSelectorError):
    set_profile_disallowed: MembersDeleteProfilePhotoError = ...
    other: MembersDeleteProfilePhotoError = ...

    def is_set_profile_disallowed(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersDeleteProfilePhotoError_validator: bv.Validator = ...

class MembersGetAvailableTeamMemberRolesResult(bb.Struct):
    def __init__(self,
                 roles: List[TeamMemberRole] = ...) -> None: ...
    roles: bb.Attribute[List[TeamMemberRole]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersGetAvailableTeamMemberRolesResult_validator: bv.Validator = ...

class MembersGetInfoArgs(bb.Struct):
    def __init__(self,
                 members: List[UserSelectorArg] = ...) -> None: ...
    members: bb.Attribute[List[UserSelectorArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersGetInfoArgs_validator: bv.Validator = ...

class MembersGetInfoError(bb.Union):
    other: MembersGetInfoError = ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersGetInfoError_validator: bv.Validator = ...

class MembersGetInfoItemBase(bb.Union):
    def is_id_not_found(self) -> bool: ...

    @classmethod
    def id_not_found(cls, val: Text) -> MembersGetInfoItemBase: ...

    def get_id_not_found(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersGetInfoItemBase_validator: bv.Validator = ...

class MembersGetInfoItem(MembersGetInfoItemBase):
    def is_member_info(self) -> bool: ...

    @classmethod
    def member_info(cls, val: TeamMemberInfo) -> MembersGetInfoItem: ...

    def get_member_info(self) -> TeamMemberInfo: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersGetInfoItem_validator: bv.Validator = ...

class MembersGetInfoItemV2(MembersGetInfoItemBase):
    other: MembersGetInfoItemV2 = ...

    def is_member_info(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def member_info(cls, val: TeamMemberInfoV2) -> MembersGetInfoItemV2: ...

    def get_member_info(self) -> TeamMemberInfoV2: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersGetInfoItemV2_validator: bv.Validator = ...

class MembersGetInfoV2Arg(bb.Struct):
    def __init__(self,
                 members: List[UserSelectorArg] = ...) -> None: ...
    members: bb.Attribute[List[UserSelectorArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersGetInfoV2Arg_validator: bv.Validator = ...

class MembersGetInfoV2Result(bb.Struct):
    def __init__(self,
                 members_info: List[MembersGetInfoItemV2] = ...) -> None: ...
    members_info: bb.Attribute[List[MembersGetInfoItemV2]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersGetInfoV2Result_validator: bv.Validator = ...

class MembersInfo(bb.Struct):
    def __init__(self,
                 team_member_ids: List[Text] = ...,
                 permanently_deleted_users: int = ...) -> None: ...
    team_member_ids: bb.Attribute[List[Text]] = ...
    permanently_deleted_users: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersInfo_validator: bv.Validator = ...

class MembersListArg(bb.Struct):
    def __init__(self,
                 limit: Optional[int] = ...,
                 include_removed: Optional[bool] = ...) -> None: ...
    limit: bb.Attribute[int] = ...
    include_removed: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersListArg_validator: bv.Validator = ...

class MembersListContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersListContinueArg_validator: bv.Validator = ...

class MembersListContinueError(bb.Union):
    invalid_cursor: MembersListContinueError = ...
    other: MembersListContinueError = ...

    def is_invalid_cursor(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersListContinueError_validator: bv.Validator = ...

class MembersListError(bb.Union):
    other: MembersListError = ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersListError_validator: bv.Validator = ...

class MembersListResult(bb.Struct):
    def __init__(self,
                 members: List[TeamMemberInfo] = ...,
                 cursor: Text = ...,
                 has_more: bool = ...) -> None: ...
    members: bb.Attribute[List[TeamMemberInfo]] = ...
    cursor: bb.Attribute[Text] = ...
    has_more: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersListResult_validator: bv.Validator = ...

class MembersListV2Result(bb.Struct):
    def __init__(self,
                 members: List[TeamMemberInfoV2] = ...,
                 cursor: Text = ...,
                 has_more: bool = ...) -> None: ...
    members: bb.Attribute[List[TeamMemberInfoV2]] = ...
    cursor: bb.Attribute[Text] = ...
    has_more: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersListV2Result_validator: bv.Validator = ...

class MembersRecoverArg(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersRecoverArg_validator: bv.Validator = ...

class MembersRecoverError(UserSelectorError):
    user_unrecoverable: MembersRecoverError = ...
    user_not_in_team: MembersRecoverError = ...
    team_license_limit: MembersRecoverError = ...
    other: MembersRecoverError = ...

    def is_user_unrecoverable(self) -> bool: ...

    def is_user_not_in_team(self) -> bool: ...

    def is_team_license_limit(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersRecoverError_validator: bv.Validator = ...

class MembersRemoveArg(MembersDeactivateArg):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 wipe_data: Optional[bool] = ...,
                 transfer_dest_id: Optional[UserSelectorArg] = ...,
                 transfer_admin_id: Optional[UserSelectorArg] = ...,
                 keep_account: Optional[bool] = ...,
                 retain_team_shares: Optional[bool] = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    wipe_data: bb.Attribute[bool] = ...
    transfer_dest_id: bb.Attribute[Optional[UserSelectorArg]] = ...
    transfer_admin_id: bb.Attribute[Optional[UserSelectorArg]] = ...
    keep_account: bb.Attribute[bool] = ...
    retain_team_shares: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersRemoveArg_validator: bv.Validator = ...

class MembersTransferFilesError(MembersDeactivateError):
    removed_and_transfer_dest_should_differ: MembersTransferFilesError = ...
    removed_and_transfer_admin_should_differ: MembersTransferFilesError = ...
    transfer_dest_user_not_found: MembersTransferFilesError = ...
    transfer_dest_user_not_in_team: MembersTransferFilesError = ...
    transfer_admin_user_not_in_team: MembersTransferFilesError = ...
    transfer_admin_user_not_found: MembersTransferFilesError = ...
    unspecified_transfer_admin_id: MembersTransferFilesError = ...
    transfer_admin_is_not_admin: MembersTransferFilesError = ...
    recipient_not_verified: MembersTransferFilesError = ...

    def is_removed_and_transfer_dest_should_differ(self) -> bool: ...

    def is_removed_and_transfer_admin_should_differ(self) -> bool: ...

    def is_transfer_dest_user_not_found(self) -> bool: ...

    def is_transfer_dest_user_not_in_team(self) -> bool: ...

    def is_transfer_admin_user_not_in_team(self) -> bool: ...

    def is_transfer_admin_user_not_found(self) -> bool: ...

    def is_unspecified_transfer_admin_id(self) -> bool: ...

    def is_transfer_admin_is_not_admin(self) -> bool: ...

    def is_recipient_not_verified(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersTransferFilesError_validator: bv.Validator = ...

class MembersRemoveError(MembersTransferFilesError):
    remove_last_admin: MembersRemoveError = ...
    cannot_keep_account_and_transfer: MembersRemoveError = ...
    cannot_keep_account_and_delete_data: MembersRemoveError = ...
    email_address_too_long_to_be_disabled: MembersRemoveError = ...
    cannot_keep_invited_user_account: MembersRemoveError = ...
    cannot_retain_shares_when_data_wiped: MembersRemoveError = ...
    cannot_retain_shares_when_no_account_kept: MembersRemoveError = ...
    cannot_retain_shares_when_team_external_sharing_off: MembersRemoveError = ...
    cannot_keep_account: MembersRemoveError = ...
    cannot_keep_account_under_legal_hold: MembersRemoveError = ...
    cannot_keep_account_required_to_sign_tos: MembersRemoveError = ...

    def is_remove_last_admin(self) -> bool: ...

    def is_cannot_keep_account_and_transfer(self) -> bool: ...

    def is_cannot_keep_account_and_delete_data(self) -> bool: ...

    def is_email_address_too_long_to_be_disabled(self) -> bool: ...

    def is_cannot_keep_invited_user_account(self) -> bool: ...

    def is_cannot_retain_shares_when_data_wiped(self) -> bool: ...

    def is_cannot_retain_shares_when_no_account_kept(self) -> bool: ...

    def is_cannot_retain_shares_when_team_external_sharing_off(self) -> bool: ...

    def is_cannot_keep_account(self) -> bool: ...

    def is_cannot_keep_account_under_legal_hold(self) -> bool: ...

    def is_cannot_keep_account_required_to_sign_tos(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersRemoveError_validator: bv.Validator = ...

class MembersSendWelcomeError(MemberSelectorError):
    other: MembersSendWelcomeError = ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSendWelcomeError_validator: bv.Validator = ...

class MembersSetPermissions2Arg(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 new_roles: Optional[List[Text]] = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    new_roles: bb.Attribute[Optional[List[Text]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSetPermissions2Arg_validator: bv.Validator = ...

class MembersSetPermissions2Error(UserSelectorError):
    last_admin: MembersSetPermissions2Error = ...
    user_not_in_team: MembersSetPermissions2Error = ...
    cannot_set_permissions: MembersSetPermissions2Error = ...
    role_not_found: MembersSetPermissions2Error = ...
    other: MembersSetPermissions2Error = ...

    def is_last_admin(self) -> bool: ...

    def is_user_not_in_team(self) -> bool: ...

    def is_cannot_set_permissions(self) -> bool: ...

    def is_role_not_found(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSetPermissions2Error_validator: bv.Validator = ...

class MembersSetPermissions2Result(bb.Struct):
    def __init__(self,
                 team_member_id: Text = ...,
                 roles: Optional[List[TeamMemberRole]] = ...) -> None: ...
    team_member_id: bb.Attribute[Text] = ...
    roles: bb.Attribute[Optional[List[TeamMemberRole]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSetPermissions2Result_validator: bv.Validator = ...

class MembersSetPermissionsArg(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 new_role: AdminTier = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    new_role: bb.Attribute[AdminTier] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSetPermissionsArg_validator: bv.Validator = ...

class MembersSetPermissionsError(UserSelectorError):
    last_admin: MembersSetPermissionsError = ...
    user_not_in_team: MembersSetPermissionsError = ...
    cannot_set_permissions: MembersSetPermissionsError = ...
    team_license_limit: MembersSetPermissionsError = ...
    other: MembersSetPermissionsError = ...

    def is_last_admin(self) -> bool: ...

    def is_user_not_in_team(self) -> bool: ...

    def is_cannot_set_permissions(self) -> bool: ...

    def is_team_license_limit(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSetPermissionsError_validator: bv.Validator = ...

class MembersSetPermissionsResult(bb.Struct):
    def __init__(self,
                 team_member_id: Text = ...,
                 role: AdminTier = ...) -> None: ...
    team_member_id: bb.Attribute[Text] = ...
    role: bb.Attribute[AdminTier] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSetPermissionsResult_validator: bv.Validator = ...

class MembersSetProfileArg(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 new_email: Optional[Text] = ...,
                 new_external_id: Optional[Text] = ...,
                 new_given_name: Optional[Text] = ...,
                 new_surname: Optional[Text] = ...,
                 new_persistent_id: Optional[Text] = ...,
                 new_is_directory_restricted: Optional[bool] = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    new_email: bb.Attribute[Optional[Text]] = ...
    new_external_id: bb.Attribute[Optional[Text]] = ...
    new_given_name: bb.Attribute[Optional[Text]] = ...
    new_surname: bb.Attribute[Optional[Text]] = ...
    new_persistent_id: bb.Attribute[Optional[Text]] = ...
    new_is_directory_restricted: bb.Attribute[Optional[bool]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSetProfileArg_validator: bv.Validator = ...

class MembersSetProfileError(MemberSelectorError):
    external_id_and_new_external_id_unsafe: MembersSetProfileError = ...
    no_new_data_specified: MembersSetProfileError = ...
    email_reserved_for_other_user: MembersSetProfileError = ...
    external_id_used_by_other_user: MembersSetProfileError = ...
    set_profile_disallowed: MembersSetProfileError = ...
    param_cannot_be_empty: MembersSetProfileError = ...
    persistent_id_disabled: MembersSetProfileError = ...
    persistent_id_used_by_other_user: MembersSetProfileError = ...
    directory_restricted_off: MembersSetProfileError = ...
    other: MembersSetProfileError = ...

    def is_external_id_and_new_external_id_unsafe(self) -> bool: ...

    def is_no_new_data_specified(self) -> bool: ...

    def is_email_reserved_for_other_user(self) -> bool: ...

    def is_external_id_used_by_other_user(self) -> bool: ...

    def is_set_profile_disallowed(self) -> bool: ...

    def is_param_cannot_be_empty(self) -> bool: ...

    def is_persistent_id_disabled(self) -> bool: ...

    def is_persistent_id_used_by_other_user(self) -> bool: ...

    def is_directory_restricted_off(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSetProfileError_validator: bv.Validator = ...

class MembersSetProfilePhotoArg(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 photo: account.PhotoSourceArg = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    photo: bb.Attribute[account.PhotoSourceArg] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSetProfilePhotoArg_validator: bv.Validator = ...

class MembersSetProfilePhotoError(MemberSelectorError):
    set_profile_disallowed: MembersSetProfilePhotoError = ...
    other: MembersSetProfilePhotoError = ...

    def is_set_profile_disallowed(self) -> bool: ...

    def is_photo_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def photo_error(cls, val: account.SetProfilePhotoError) -> MembersSetProfilePhotoError: ...

    def get_photo_error(self) -> account.SetProfilePhotoError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSetProfilePhotoError_validator: bv.Validator = ...

class MembersSuspendError(MembersDeactivateError):
    suspend_inactive_user: MembersSuspendError = ...
    suspend_last_admin: MembersSuspendError = ...
    team_license_limit: MembersSuspendError = ...

    def is_suspend_inactive_user(self) -> bool: ...

    def is_suspend_last_admin(self) -> bool: ...

    def is_team_license_limit(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersSuspendError_validator: bv.Validator = ...

class MembersTransferFormerMembersFilesError(MembersTransferFilesError):
    user_data_is_being_transferred: MembersTransferFormerMembersFilesError = ...
    user_not_removed: MembersTransferFormerMembersFilesError = ...
    user_data_cannot_be_transferred: MembersTransferFormerMembersFilesError = ...
    user_data_already_transferred: MembersTransferFormerMembersFilesError = ...

    def is_user_data_is_being_transferred(self) -> bool: ...

    def is_user_not_removed(self) -> bool: ...

    def is_user_data_cannot_be_transferred(self) -> bool: ...

    def is_user_data_already_transferred(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersTransferFormerMembersFilesError_validator: bv.Validator = ...

class MembersUnsuspendArg(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersUnsuspendArg_validator: bv.Validator = ...

class MembersUnsuspendError(MembersDeactivateError):
    unsuspend_non_suspended_member: MembersUnsuspendError = ...
    team_license_limit: MembersUnsuspendError = ...

    def is_unsuspend_non_suspended_member(self) -> bool: ...

    def is_team_license_limit(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembersUnsuspendError_validator: bv.Validator = ...

class MobileClientPlatform(bb.Union):
    iphone: MobileClientPlatform = ...
    ipad: MobileClientPlatform = ...
    android: MobileClientPlatform = ...
    windows_phone: MobileClientPlatform = ...
    blackberry: MobileClientPlatform = ...
    other: MobileClientPlatform = ...

    def is_iphone(self) -> bool: ...

    def is_ipad(self) -> bool: ...

    def is_android(self) -> bool: ...

    def is_windows_phone(self) -> bool: ...

    def is_blackberry(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MobileClientPlatform_validator: bv.Validator = ...

class MobileClientSession(DeviceSession):
    def __init__(self,
                 session_id: Text = ...,
                 device_name: Text = ...,
                 client_type: MobileClientPlatform = ...,
                 ip_address: Optional[Text] = ...,
                 country: Optional[Text] = ...,
                 created: Optional[datetime.datetime] = ...,
                 updated: Optional[datetime.datetime] = ...,
                 client_version: Optional[Text] = ...,
                 os_version: Optional[Text] = ...,
                 last_carrier: Optional[Text] = ...) -> None: ...
    session_id: bb.Attribute[Text] = ...
    device_name: bb.Attribute[Text] = ...
    client_type: bb.Attribute[MobileClientPlatform] = ...
    ip_address: bb.Attribute[Optional[Text]] = ...
    country: bb.Attribute[Optional[Text]] = ...
    created: bb.Attribute[Optional[datetime.datetime]] = ...
    updated: bb.Attribute[Optional[datetime.datetime]] = ...
    client_version: bb.Attribute[Optional[Text]] = ...
    os_version: bb.Attribute[Optional[Text]] = ...
    last_carrier: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MobileClientSession_validator: bv.Validator = ...

class NamespaceMetadata(bb.Struct):
    def __init__(self,
                 name: Text = ...,
                 namespace_id: Text = ...,
                 namespace_type: NamespaceType = ...,
                 team_member_id: Optional[Text] = ...) -> None: ...
    name: bb.Attribute[Text] = ...
    namespace_id: bb.Attribute[Text] = ...
    namespace_type: bb.Attribute[NamespaceType] = ...
    team_member_id: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

NamespaceMetadata_validator: bv.Validator = ...

class NamespaceType(bb.Union):
    app_folder: NamespaceType = ...
    shared_folder: NamespaceType = ...
    team_folder: NamespaceType = ...
    team_member_folder: NamespaceType = ...
    other: NamespaceType = ...

    def is_app_folder(self) -> bool: ...

    def is_shared_folder(self) -> bool: ...

    def is_team_folder(self) -> bool: ...

    def is_team_member_folder(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

NamespaceType_validator: bv.Validator = ...

class RemoveCustomQuotaResult(bb.Union):
    other: RemoveCustomQuotaResult = ...

    def is_success(self) -> bool: ...

    def is_invalid_user(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: UserSelectorArg) -> RemoveCustomQuotaResult: ...

    @classmethod
    def invalid_user(cls, val: UserSelectorArg) -> RemoveCustomQuotaResult: ...

    def get_success(self) -> UserSelectorArg: ...

    def get_invalid_user(self) -> UserSelectorArg: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RemoveCustomQuotaResult_validator: bv.Validator = ...

class RemovedStatus(bb.Struct):
    def __init__(self,
                 is_recoverable: bool = ...,
                 is_disconnected: bool = ...) -> None: ...
    is_recoverable: bb.Attribute[bool] = ...
    is_disconnected: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RemovedStatus_validator: bv.Validator = ...

class ResendSecondaryEmailResult(bb.Union):
    other: ResendSecondaryEmailResult = ...

    def is_success(self) -> bool: ...

    def is_not_pending(self) -> bool: ...

    def is_rate_limited(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: Text) -> ResendSecondaryEmailResult: ...

    @classmethod
    def not_pending(cls, val: Text) -> ResendSecondaryEmailResult: ...

    @classmethod
    def rate_limited(cls, val: Text) -> ResendSecondaryEmailResult: ...

    def get_success(self) -> Text: ...

    def get_not_pending(self) -> Text: ...

    def get_rate_limited(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ResendSecondaryEmailResult_validator: bv.Validator = ...

class ResendVerificationEmailArg(bb.Struct):
    def __init__(self,
                 emails_to_resend: List[UserSecondaryEmailsArg] = ...) -> None: ...
    emails_to_resend: bb.Attribute[List[UserSecondaryEmailsArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ResendVerificationEmailArg_validator: bv.Validator = ...

class ResendVerificationEmailResult(bb.Struct):
    def __init__(self,
                 results: List[UserResendResult] = ...) -> None: ...
    results: bb.Attribute[List[UserResendResult]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ResendVerificationEmailResult_validator: bv.Validator = ...

class RevokeDesktopClientArg(DeviceSessionArg):
    def __init__(self,
                 session_id: Text = ...,
                 team_member_id: Text = ...,
                 delete_on_unlink: Optional[bool] = ...) -> None: ...
    session_id: bb.Attribute[Text] = ...
    team_member_id: bb.Attribute[Text] = ...
    delete_on_unlink: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeDesktopClientArg_validator: bv.Validator = ...

class RevokeDeviceSessionArg(bb.Union):
    def is_web_session(self) -> bool: ...

    def is_desktop_client(self) -> bool: ...

    def is_mobile_client(self) -> bool: ...

    @classmethod
    def web_session(cls, val: DeviceSessionArg) -> RevokeDeviceSessionArg: ...

    @classmethod
    def desktop_client(cls, val: RevokeDesktopClientArg) -> RevokeDeviceSessionArg: ...

    @classmethod
    def mobile_client(cls, val: DeviceSessionArg) -> RevokeDeviceSessionArg: ...

    def get_web_session(self) -> DeviceSessionArg: ...

    def get_desktop_client(self) -> RevokeDesktopClientArg: ...

    def get_mobile_client(self) -> DeviceSessionArg: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeDeviceSessionArg_validator: bv.Validator = ...

class RevokeDeviceSessionBatchArg(bb.Struct):
    def __init__(self,
                 revoke_devices: List[RevokeDeviceSessionArg] = ...) -> None: ...
    revoke_devices: bb.Attribute[List[RevokeDeviceSessionArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeDeviceSessionBatchArg_validator: bv.Validator = ...

class RevokeDeviceSessionBatchError(bb.Union):
    other: RevokeDeviceSessionBatchError = ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeDeviceSessionBatchError_validator: bv.Validator = ...

class RevokeDeviceSessionBatchResult(bb.Struct):
    def __init__(self,
                 revoke_devices_status: List[RevokeDeviceSessionStatus] = ...) -> None: ...
    revoke_devices_status: bb.Attribute[List[RevokeDeviceSessionStatus]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeDeviceSessionBatchResult_validator: bv.Validator = ...

class RevokeDeviceSessionError(bb.Union):
    device_session_not_found: RevokeDeviceSessionError = ...
    member_not_found: RevokeDeviceSessionError = ...
    other: RevokeDeviceSessionError = ...

    def is_device_session_not_found(self) -> bool: ...

    def is_member_not_found(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeDeviceSessionError_validator: bv.Validator = ...

class RevokeDeviceSessionStatus(bb.Struct):
    def __init__(self,
                 success: bool = ...,
                 error_type: Optional[RevokeDeviceSessionError] = ...) -> None: ...
    success: bb.Attribute[bool] = ...
    error_type: bb.Attribute[Optional[RevokeDeviceSessionError]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeDeviceSessionStatus_validator: bv.Validator = ...

class RevokeLinkedApiAppArg(bb.Struct):
    def __init__(self,
                 app_id: Text = ...,
                 team_member_id: Text = ...,
                 keep_app_folder: Optional[bool] = ...) -> None: ...
    app_id: bb.Attribute[Text] = ...
    team_member_id: bb.Attribute[Text] = ...
    keep_app_folder: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeLinkedApiAppArg_validator: bv.Validator = ...

class RevokeLinkedApiAppBatchArg(bb.Struct):
    def __init__(self,
                 revoke_linked_app: List[RevokeLinkedApiAppArg] = ...) -> None: ...
    revoke_linked_app: bb.Attribute[List[RevokeLinkedApiAppArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeLinkedApiAppBatchArg_validator: bv.Validator = ...

class RevokeLinkedAppBatchError(bb.Union):
    other: RevokeLinkedAppBatchError = ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeLinkedAppBatchError_validator: bv.Validator = ...

class RevokeLinkedAppBatchResult(bb.Struct):
    def __init__(self,
                 revoke_linked_app_status: List[RevokeLinkedAppStatus] = ...) -> None: ...
    revoke_linked_app_status: bb.Attribute[List[RevokeLinkedAppStatus]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeLinkedAppBatchResult_validator: bv.Validator = ...

class RevokeLinkedAppError(bb.Union):
    app_not_found: RevokeLinkedAppError = ...
    member_not_found: RevokeLinkedAppError = ...
    app_folder_removal_not_supported: RevokeLinkedAppError = ...
    other: RevokeLinkedAppError = ...

    def is_app_not_found(self) -> bool: ...

    def is_member_not_found(self) -> bool: ...

    def is_app_folder_removal_not_supported(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeLinkedAppError_validator: bv.Validator = ...

class RevokeLinkedAppStatus(bb.Struct):
    def __init__(self,
                 success: bool = ...,
                 error_type: Optional[RevokeLinkedAppError] = ...) -> None: ...
    success: bb.Attribute[bool] = ...
    error_type: bb.Attribute[Optional[RevokeLinkedAppError]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeLinkedAppStatus_validator: bv.Validator = ...

class SetCustomQuotaArg(bb.Struct):
    def __init__(self,
                 users_and_quotas: List[UserCustomQuotaArg] = ...) -> None: ...
    users_and_quotas: bb.Attribute[List[UserCustomQuotaArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SetCustomQuotaArg_validator: bv.Validator = ...

class SetCustomQuotaError(CustomQuotaError):
    some_users_are_excluded: SetCustomQuotaError = ...

    def is_some_users_are_excluded(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SetCustomQuotaError_validator: bv.Validator = ...

class StorageBucket(bb.Struct):
    def __init__(self,
                 bucket: Text = ...,
                 users: int = ...) -> None: ...
    bucket: bb.Attribute[Text] = ...
    users: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

StorageBucket_validator: bv.Validator = ...

class TeamFolderAccessError(bb.Union):
    invalid_team_folder_id: TeamFolderAccessError = ...
    no_access: TeamFolderAccessError = ...
    other: TeamFolderAccessError = ...

    def is_invalid_team_folder_id(self) -> bool: ...

    def is_no_access(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderAccessError_validator: bv.Validator = ...

class TeamFolderActivateError(BaseTeamFolderError):
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderActivateError_validator: bv.Validator = ...

class TeamFolderIdArg(bb.Struct):
    def __init__(self,
                 team_folder_id: Text = ...) -> None: ...
    team_folder_id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderIdArg_validator: bv.Validator = ...

class TeamFolderArchiveArg(TeamFolderIdArg):
    def __init__(self,
                 team_folder_id: Text = ...,
                 force_async_off: Optional[bool] = ...) -> None: ...
    team_folder_id: bb.Attribute[Text] = ...
    force_async_off: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderArchiveArg_validator: bv.Validator = ...

class TeamFolderArchiveError(BaseTeamFolderError):
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderArchiveError_validator: bv.Validator = ...

class TeamFolderArchiveJobStatus(async_.PollResultBase):
    def is_complete(self) -> bool: ...

    def is_failed(self) -> bool: ...

    @classmethod
    def complete(cls, val: TeamFolderMetadata) -> TeamFolderArchiveJobStatus: ...

    @classmethod
    def failed(cls, val: TeamFolderArchiveError) -> TeamFolderArchiveJobStatus: ...

    def get_complete(self) -> TeamFolderMetadata: ...

    def get_failed(self) -> TeamFolderArchiveError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderArchiveJobStatus_validator: bv.Validator = ...

class TeamFolderArchiveLaunch(async_.LaunchResultBase):
    def is_complete(self) -> bool: ...

    @classmethod
    def complete(cls, val: TeamFolderMetadata) -> TeamFolderArchiveLaunch: ...

    def get_complete(self) -> TeamFolderMetadata: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderArchiveLaunch_validator: bv.Validator = ...

class TeamFolderCreateArg(bb.Struct):
    def __init__(self,
                 name: Text = ...,
                 sync_setting: Optional[files.SyncSettingArg] = ...) -> None: ...
    name: bb.Attribute[Text] = ...
    sync_setting: bb.Attribute[Optional[files.SyncSettingArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderCreateArg_validator: bv.Validator = ...

class TeamFolderCreateError(bb.Union):
    invalid_folder_name: TeamFolderCreateError = ...
    folder_name_already_used: TeamFolderCreateError = ...
    folder_name_reserved: TeamFolderCreateError = ...
    other: TeamFolderCreateError = ...

    def is_invalid_folder_name(self) -> bool: ...

    def is_folder_name_already_used(self) -> bool: ...

    def is_folder_name_reserved(self) -> bool: ...

    def is_sync_settings_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def sync_settings_error(cls, val: files.SyncSettingsError) -> TeamFolderCreateError: ...

    def get_sync_settings_error(self) -> files.SyncSettingsError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderCreateError_validator: bv.Validator = ...

class TeamFolderGetInfoItem(bb.Union):
    def is_id_not_found(self) -> bool: ...

    def is_team_folder_metadata(self) -> bool: ...

    @classmethod
    def id_not_found(cls, val: Text) -> TeamFolderGetInfoItem: ...

    @classmethod
    def team_folder_metadata(cls, val: TeamFolderMetadata) -> TeamFolderGetInfoItem: ...

    def get_id_not_found(self) -> Text: ...

    def get_team_folder_metadata(self) -> TeamFolderMetadata: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderGetInfoItem_validator: bv.Validator = ...

class TeamFolderIdListArg(bb.Struct):
    def __init__(self,
                 team_folder_ids: List[Text] = ...) -> None: ...
    team_folder_ids: bb.Attribute[List[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderIdListArg_validator: bv.Validator = ...

class TeamFolderInvalidStatusError(bb.Union):
    active: TeamFolderInvalidStatusError = ...
    archived: TeamFolderInvalidStatusError = ...
    archive_in_progress: TeamFolderInvalidStatusError = ...
    other: TeamFolderInvalidStatusError = ...

    def is_active(self) -> bool: ...

    def is_archived(self) -> bool: ...

    def is_archive_in_progress(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderInvalidStatusError_validator: bv.Validator = ...

class TeamFolderListArg(bb.Struct):
    def __init__(self,
                 limit: Optional[int] = ...) -> None: ...
    limit: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderListArg_validator: bv.Validator = ...

class TeamFolderListContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderListContinueArg_validator: bv.Validator = ...

class TeamFolderListContinueError(bb.Union):
    invalid_cursor: TeamFolderListContinueError = ...
    other: TeamFolderListContinueError = ...

    def is_invalid_cursor(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderListContinueError_validator: bv.Validator = ...

class TeamFolderListError(bb.Struct):
    def __init__(self,
                 access_error: TeamFolderAccessError = ...) -> None: ...
    access_error: bb.Attribute[TeamFolderAccessError] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderListError_validator: bv.Validator = ...

class TeamFolderListResult(bb.Struct):
    def __init__(self,
                 team_folders: List[TeamFolderMetadata] = ...,
                 cursor: Text = ...,
                 has_more: bool = ...) -> None: ...
    team_folders: bb.Attribute[List[TeamFolderMetadata]] = ...
    cursor: bb.Attribute[Text] = ...
    has_more: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderListResult_validator: bv.Validator = ...

class TeamFolderMetadata(bb.Struct):
    def __init__(self,
                 team_folder_id: Text = ...,
                 name: Text = ...,
                 status: TeamFolderStatus = ...,
                 is_team_shared_dropbox: bool = ...,
                 sync_setting: files.SyncSetting = ...,
                 content_sync_settings: List[files.ContentSyncSetting] = ...) -> None: ...
    team_folder_id: bb.Attribute[Text] = ...
    name: bb.Attribute[Text] = ...
    status: bb.Attribute[TeamFolderStatus] = ...
    is_team_shared_dropbox: bb.Attribute[bool] = ...
    sync_setting: bb.Attribute[files.SyncSetting] = ...
    content_sync_settings: bb.Attribute[List[files.ContentSyncSetting]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderMetadata_validator: bv.Validator = ...

class TeamFolderPermanentlyDeleteError(BaseTeamFolderError):
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderPermanentlyDeleteError_validator: bv.Validator = ...

class TeamFolderRenameArg(TeamFolderIdArg):
    def __init__(self,
                 team_folder_id: Text = ...,
                 name: Text = ...) -> None: ...
    team_folder_id: bb.Attribute[Text] = ...
    name: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderRenameArg_validator: bv.Validator = ...

class TeamFolderRenameError(BaseTeamFolderError):
    invalid_folder_name: TeamFolderRenameError = ...
    folder_name_already_used: TeamFolderRenameError = ...
    folder_name_reserved: TeamFolderRenameError = ...

    def is_invalid_folder_name(self) -> bool: ...

    def is_folder_name_already_used(self) -> bool: ...

    def is_folder_name_reserved(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderRenameError_validator: bv.Validator = ...

class TeamFolderStatus(bb.Union):
    active: TeamFolderStatus = ...
    archived: TeamFolderStatus = ...
    archive_in_progress: TeamFolderStatus = ...
    other: TeamFolderStatus = ...

    def is_active(self) -> bool: ...

    def is_archived(self) -> bool: ...

    def is_archive_in_progress(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderStatus_validator: bv.Validator = ...

class TeamFolderTeamSharedDropboxError(bb.Union):
    disallowed: TeamFolderTeamSharedDropboxError = ...
    other: TeamFolderTeamSharedDropboxError = ...

    def is_disallowed(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderTeamSharedDropboxError_validator: bv.Validator = ...

class TeamFolderUpdateSyncSettingsArg(TeamFolderIdArg):
    def __init__(self,
                 team_folder_id: Text = ...,
                 sync_setting: Optional[files.SyncSettingArg] = ...,
                 content_sync_settings: Optional[List[files.ContentSyncSettingArg]] = ...) -> None: ...
    team_folder_id: bb.Attribute[Text] = ...
    sync_setting: bb.Attribute[Optional[files.SyncSettingArg]] = ...
    content_sync_settings: bb.Attribute[Optional[List[files.ContentSyncSettingArg]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderUpdateSyncSettingsArg_validator: bv.Validator = ...

class TeamFolderUpdateSyncSettingsError(BaseTeamFolderError):
    def is_sync_settings_error(self) -> bool: ...

    @classmethod
    def sync_settings_error(cls, val: files.SyncSettingsError) -> TeamFolderUpdateSyncSettingsError: ...

    def get_sync_settings_error(self) -> files.SyncSettingsError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamFolderUpdateSyncSettingsError_validator: bv.Validator = ...

class TeamGetInfoResult(bb.Struct):
    def __init__(self,
                 name: Text = ...,
                 team_id: Text = ...,
                 num_licensed_users: int = ...,
                 num_provisioned_users: int = ...,
                 policies: team_policies.TeamMemberPolicies = ...) -> None: ...
    name: bb.Attribute[Text] = ...
    team_id: bb.Attribute[Text] = ...
    num_licensed_users: bb.Attribute[int] = ...
    num_provisioned_users: bb.Attribute[int] = ...
    policies: bb.Attribute[team_policies.TeamMemberPolicies] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamGetInfoResult_validator: bv.Validator = ...

class TeamMemberInfo(bb.Struct):
    def __init__(self,
                 profile: TeamMemberProfile = ...,
                 role: AdminTier = ...) -> None: ...
    profile: bb.Attribute[TeamMemberProfile] = ...
    role: bb.Attribute[AdminTier] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamMemberInfo_validator: bv.Validator = ...

class TeamMemberInfoV2(bb.Struct):
    def __init__(self,
                 profile: TeamMemberProfile = ...,
                 roles: Optional[List[TeamMemberRole]] = ...) -> None: ...
    profile: bb.Attribute[TeamMemberProfile] = ...
    roles: bb.Attribute[Optional[List[TeamMemberRole]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamMemberInfoV2_validator: bv.Validator = ...

class TeamMemberInfoV2Result(bb.Struct):
    def __init__(self,
                 member_info: TeamMemberInfoV2 = ...) -> None: ...
    member_info: bb.Attribute[TeamMemberInfoV2] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamMemberInfoV2Result_validator: bv.Validator = ...

class TeamMemberProfile(MemberProfile):
    def __init__(self,
                 team_member_id: Text = ...,
                 email: Text = ...,
                 email_verified: bool = ...,
                 status: TeamMemberStatus = ...,
                 name: users.Name = ...,
                 membership_type: TeamMembershipType = ...,
                 groups: List[Text] = ...,
                 member_folder_id: Text = ...,
                 external_id: Optional[Text] = ...,
                 account_id: Optional[Text] = ...,
                 secondary_emails: Optional[List[secondary_emails.SecondaryEmail]] = ...,
                 invited_on: Optional[datetime.datetime] = ...,
                 joined_on: Optional[datetime.datetime] = ...,
                 suspended_on: Optional[datetime.datetime] = ...,
                 persistent_id: Optional[Text] = ...,
                 is_directory_restricted: Optional[bool] = ...,
                 profile_photo_url: Optional[Text] = ...) -> None: ...
    team_member_id: bb.Attribute[Text] = ...
    email: bb.Attribute[Text] = ...
    email_verified: bb.Attribute[bool] = ...
    status: bb.Attribute[TeamMemberStatus] = ...
    name: bb.Attribute[users.Name] = ...
    membership_type: bb.Attribute[TeamMembershipType] = ...
    groups: bb.Attribute[List[Text]] = ...
    member_folder_id: bb.Attribute[Text] = ...
    external_id: bb.Attribute[Optional[Text]] = ...
    account_id: bb.Attribute[Optional[Text]] = ...
    secondary_emails: bb.Attribute[Optional[List[secondary_emails.SecondaryEmail]]] = ...
    invited_on: bb.Attribute[Optional[datetime.datetime]] = ...
    joined_on: bb.Attribute[Optional[datetime.datetime]] = ...
    suspended_on: bb.Attribute[Optional[datetime.datetime]] = ...
    persistent_id: bb.Attribute[Optional[Text]] = ...
    is_directory_restricted: bb.Attribute[Optional[bool]] = ...
    profile_photo_url: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamMemberProfile_validator: bv.Validator = ...

class TeamMemberRole(bb.Struct):
    def __init__(self,
                 role_id: Text = ...,
                 name: Text = ...,
                 description: Text = ...) -> None: ...
    role_id: bb.Attribute[Text] = ...
    name: bb.Attribute[Text] = ...
    description: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamMemberRole_validator: bv.Validator = ...

class TeamMemberStatus(bb.Union):
    active: TeamMemberStatus = ...
    invited: TeamMemberStatus = ...
    suspended: TeamMemberStatus = ...

    def is_active(self) -> bool: ...

    def is_invited(self) -> bool: ...

    def is_suspended(self) -> bool: ...

    def is_removed(self) -> bool: ...

    @classmethod
    def removed(cls, val: RemovedStatus) -> TeamMemberStatus: ...

    def get_removed(self) -> RemovedStatus: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamMemberStatus_validator: bv.Validator = ...

class TeamMembershipType(bb.Union):
    full: TeamMembershipType = ...
    limited: TeamMembershipType = ...

    def is_full(self) -> bool: ...

    def is_limited(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamMembershipType_validator: bv.Validator = ...

class TeamNamespacesListArg(bb.Struct):
    def __init__(self,
                 limit: Optional[int] = ...) -> None: ...
    limit: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamNamespacesListArg_validator: bv.Validator = ...

class TeamNamespacesListContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamNamespacesListContinueArg_validator: bv.Validator = ...

class TeamNamespacesListError(bb.Union):
    invalid_arg: TeamNamespacesListError = ...
    other: TeamNamespacesListError = ...

    def is_invalid_arg(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamNamespacesListError_validator: bv.Validator = ...

class TeamNamespacesListContinueError(TeamNamespacesListError):
    invalid_cursor: TeamNamespacesListContinueError = ...

    def is_invalid_cursor(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamNamespacesListContinueError_validator: bv.Validator = ...

class TeamNamespacesListResult(bb.Struct):
    def __init__(self,
                 namespaces: List[NamespaceMetadata] = ...,
                 cursor: Text = ...,
                 has_more: bool = ...) -> None: ...
    namespaces: bb.Attribute[List[NamespaceMetadata]] = ...
    cursor: bb.Attribute[Text] = ...
    has_more: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamNamespacesListResult_validator: bv.Validator = ...

class TeamReportFailureReason(bb.Union):
    temporary_error: TeamReportFailureReason = ...
    many_reports_at_once: TeamReportFailureReason = ...
    too_much_data: TeamReportFailureReason = ...
    other: TeamReportFailureReason = ...

    def is_temporary_error(self) -> bool: ...

    def is_many_reports_at_once(self) -> bool: ...

    def is_too_much_data(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamReportFailureReason_validator: bv.Validator = ...

class TokenGetAuthenticatedAdminError(bb.Union):
    mapping_not_found: TokenGetAuthenticatedAdminError = ...
    admin_not_active: TokenGetAuthenticatedAdminError = ...
    other: TokenGetAuthenticatedAdminError = ...

    def is_mapping_not_found(self) -> bool: ...

    def is_admin_not_active(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TokenGetAuthenticatedAdminError_validator: bv.Validator = ...

class TokenGetAuthenticatedAdminResult(bb.Struct):
    def __init__(self,
                 admin_profile: TeamMemberProfile = ...) -> None: ...
    admin_profile: bb.Attribute[TeamMemberProfile] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TokenGetAuthenticatedAdminResult_validator: bv.Validator = ...

class UploadApiRateLimitValue(bb.Union):
    unlimited: UploadApiRateLimitValue = ...
    other: UploadApiRateLimitValue = ...

    def is_unlimited(self) -> bool: ...

    def is_limit(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def limit(cls, val: int) -> UploadApiRateLimitValue: ...

    def get_limit(self) -> int: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadApiRateLimitValue_validator: bv.Validator = ...

class UserAddResult(bb.Union):
    other: UserAddResult = ...

    def is_success(self) -> bool: ...

    def is_invalid_user(self) -> bool: ...

    def is_unverified(self) -> bool: ...

    def is_placeholder_user(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: UserSecondaryEmailsResult) -> UserAddResult: ...

    @classmethod
    def invalid_user(cls, val: UserSelectorArg) -> UserAddResult: ...

    @classmethod
    def unverified(cls, val: UserSelectorArg) -> UserAddResult: ...

    @classmethod
    def placeholder_user(cls, val: UserSelectorArg) -> UserAddResult: ...

    def get_success(self) -> UserSecondaryEmailsResult: ...

    def get_invalid_user(self) -> UserSelectorArg: ...

    def get_unverified(self) -> UserSelectorArg: ...

    def get_placeholder_user(self) -> UserSelectorArg: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserAddResult_validator: bv.Validator = ...

class UserCustomQuotaArg(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 quota_gb: int = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    quota_gb: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserCustomQuotaArg_validator: bv.Validator = ...

class UserCustomQuotaResult(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 quota_gb: Optional[int] = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    quota_gb: bb.Attribute[Optional[int]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserCustomQuotaResult_validator: bv.Validator = ...

class UserDeleteEmailsResult(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 results: List[DeleteSecondaryEmailResult] = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    results: bb.Attribute[List[DeleteSecondaryEmailResult]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserDeleteEmailsResult_validator: bv.Validator = ...

class UserDeleteResult(bb.Union):
    other: UserDeleteResult = ...

    def is_success(self) -> bool: ...

    def is_invalid_user(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: UserDeleteEmailsResult) -> UserDeleteResult: ...

    @classmethod
    def invalid_user(cls, val: UserSelectorArg) -> UserDeleteResult: ...

    def get_success(self) -> UserDeleteEmailsResult: ...

    def get_invalid_user(self) -> UserSelectorArg: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserDeleteResult_validator: bv.Validator = ...

class UserResendEmailsResult(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 results: List[ResendSecondaryEmailResult] = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    results: bb.Attribute[List[ResendSecondaryEmailResult]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserResendEmailsResult_validator: bv.Validator = ...

class UserResendResult(bb.Union):
    other: UserResendResult = ...

    def is_success(self) -> bool: ...

    def is_invalid_user(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: UserResendEmailsResult) -> UserResendResult: ...

    @classmethod
    def invalid_user(cls, val: UserSelectorArg) -> UserResendResult: ...

    def get_success(self) -> UserResendEmailsResult: ...

    def get_invalid_user(self) -> UserSelectorArg: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserResendResult_validator: bv.Validator = ...

class UserSecondaryEmailsArg(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 secondary_emails: List[Text] = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    secondary_emails: bb.Attribute[List[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserSecondaryEmailsArg_validator: bv.Validator = ...

class UserSecondaryEmailsResult(bb.Struct):
    def __init__(self,
                 user: UserSelectorArg = ...,
                 results: List[AddSecondaryEmailResult] = ...) -> None: ...
    user: bb.Attribute[UserSelectorArg] = ...
    results: bb.Attribute[List[AddSecondaryEmailResult]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserSecondaryEmailsResult_validator: bv.Validator = ...

class UserSelectorArg(bb.Union):
    def is_team_member_id(self) -> bool: ...

    def is_external_id(self) -> bool: ...

    def is_email(self) -> bool: ...

    @classmethod
    def team_member_id(cls, val: Text) -> UserSelectorArg: ...

    @classmethod
    def external_id(cls, val: Text) -> UserSelectorArg: ...

    @classmethod
    def email(cls, val: Text) -> UserSelectorArg: ...

    def get_team_member_id(self) -> Text: ...

    def get_external_id(self) -> Text: ...

    def get_email(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserSelectorArg_validator: bv.Validator = ...

class UsersSelectorArg(bb.Union):
    def is_team_member_ids(self) -> bool: ...

    def is_external_ids(self) -> bool: ...

    def is_emails(self) -> bool: ...

    @classmethod
    def team_member_ids(cls, val: List[Text]) -> UsersSelectorArg: ...

    @classmethod
    def external_ids(cls, val: List[Text]) -> UsersSelectorArg: ...

    @classmethod
    def emails(cls, val: List[Text]) -> UsersSelectorArg: ...

    def get_team_member_ids(self) -> List[Text]: ...

    def get_external_ids(self) -> List[Text]: ...

    def get_emails(self) -> List[Text]: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UsersSelectorArg_validator: bv.Validator = ...

GroupsGetInfoResult_validator: bv.Validator = ...
LegalHoldId_validator: bv.Validator = ...
LegalHoldPolicyDescription_validator: bv.Validator = ...
LegalHoldPolicyName_validator: bv.Validator = ...
LegalHoldsGetPolicyResult_validator: bv.Validator = ...
LegalHoldsGetPolicyResult = LegalHoldPolicy
LegalHoldsPolicyCreateResult_validator: bv.Validator = ...
LegalHoldsPolicyCreateResult = LegalHoldPolicy
LegalHoldsPolicyUpdateResult_validator: bv.Validator = ...
LegalHoldsPolicyUpdateResult = LegalHoldPolicy
ListHeldRevisionCursor_validator: bv.Validator = ...
MembersGetInfoResult_validator: bv.Validator = ...
NumberPerDay_validator: bv.Validator = ...
Path_validator: bv.Validator = ...
SecondaryEmail_validator: bv.Validator = ...
SecondaryEmail = secondary_emails.SecondaryEmail
TeamMemberRoleId_validator: bv.Validator = ...
UserQuota_validator: bv.Validator = ...
devices_list_member_devices: bb.Route = ...
devices_list_members_devices: bb.Route = ...
devices_list_team_devices: bb.Route = ...
devices_revoke_device_session: bb.Route = ...
devices_revoke_device_session_batch: bb.Route = ...
features_get_values: bb.Route = ...
get_info: bb.Route = ...
groups_create: bb.Route = ...
groups_delete: bb.Route = ...
groups_get_info: bb.Route = ...
groups_job_status_get: bb.Route = ...
groups_list: bb.Route = ...
groups_list_continue: bb.Route = ...
groups_members_add: bb.Route = ...
groups_members_list: bb.Route = ...
groups_members_list_continue: bb.Route = ...
groups_members_remove: bb.Route = ...
groups_members_set_access_type: bb.Route = ...
groups_update: bb.Route = ...
legal_holds_create_policy: bb.Route = ...
legal_holds_get_policy: bb.Route = ...
legal_holds_list_held_revisions: bb.Route = ...
legal_holds_list_held_revisions_continue: bb.Route = ...
legal_holds_list_policies: bb.Route = ...
legal_holds_release_policy: bb.Route = ...
legal_holds_update_policy: bb.Route = ...
linked_apps_list_member_linked_apps: bb.Route = ...
linked_apps_list_members_linked_apps: bb.Route = ...
linked_apps_list_team_linked_apps: bb.Route = ...
linked_apps_revoke_linked_app: bb.Route = ...
linked_apps_revoke_linked_app_batch: bb.Route = ...
member_space_limits_excluded_users_add: bb.Route = ...
member_space_limits_excluded_users_list: bb.Route = ...
member_space_limits_excluded_users_list_continue: bb.Route = ...
member_space_limits_excluded_users_remove: bb.Route = ...
member_space_limits_get_custom_quota: bb.Route = ...
member_space_limits_remove_custom_quota: bb.Route = ...
member_space_limits_set_custom_quota: bb.Route = ...
members_add_v2: bb.Route = ...
members_add: bb.Route = ...
members_add_job_status_get_v2: bb.Route = ...
members_add_job_status_get: bb.Route = ...
members_delete_profile_photo_v2: bb.Route = ...
members_delete_profile_photo: bb.Route = ...
members_get_available_team_member_roles: bb.Route = ...
members_get_info_v2: bb.Route = ...
members_get_info: bb.Route = ...
members_list_v2: bb.Route = ...
members_list: bb.Route = ...
members_list_continue_v2: bb.Route = ...
members_list_continue: bb.Route = ...
members_move_former_member_files: bb.Route = ...
members_move_former_member_files_job_status_check: bb.Route = ...
members_recover: bb.Route = ...
members_remove: bb.Route = ...
members_remove_job_status_get: bb.Route = ...
members_secondary_emails_add: bb.Route = ...
members_secondary_emails_delete: bb.Route = ...
members_secondary_emails_resend_verification_emails: bb.Route = ...
members_send_welcome_email: bb.Route = ...
members_set_admin_permissions_v2: bb.Route = ...
members_set_admin_permissions: bb.Route = ...
members_set_profile_v2: bb.Route = ...
members_set_profile: bb.Route = ...
members_set_profile_photo_v2: bb.Route = ...
members_set_profile_photo: bb.Route = ...
members_suspend: bb.Route = ...
members_unsuspend: bb.Route = ...
namespaces_list: bb.Route = ...
namespaces_list_continue: bb.Route = ...
properties_template_add: bb.Route = ...
properties_template_get: bb.Route = ...
properties_template_list: bb.Route = ...
properties_template_update: bb.Route = ...
reports_get_activity: bb.Route = ...
reports_get_devices: bb.Route = ...
reports_get_membership: bb.Route = ...
reports_get_storage: bb.Route = ...
team_folder_activate: bb.Route = ...
team_folder_archive: bb.Route = ...
team_folder_archive_check: bb.Route = ...
team_folder_create: bb.Route = ...
team_folder_get_info: bb.Route = ...
team_folder_list: bb.Route = ...
team_folder_list_continue: bb.Route = ...
team_folder_permanently_delete: bb.Route = ...
team_folder_rename: bb.Route = ...
team_folder_update_sync_settings: bb.Route = ...
token_get_authenticated_admin: bb.Route = ...


# -*- coding: utf-8 -*-
# Auto-generated by Stone, do not modify.
# @generated
# flake8: noqa
# pylint: skip-file

from typing import (
    Callable,
    Optional,
    Text,
    Type,
    TypeVar,
)
from stone.backends.python_rsrc import stone_base as bb  # type: ignore
from stone.backends.python_rsrc import stone_validators as bv  # type: ignore

T = TypeVar('T', bound=bb.AnnotationType)
U = TypeVar('U')

class AccessError(bb.Union):
    other: AccessError = ...

    def is_invalid_account_type(self) -> bool: ...

    def is_paper_access_denied(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def invalid_account_type(cls, val: InvalidAccountTypeError) -> AccessError: ...

    @classmethod
    def paper_access_denied(cls, val: PaperAccessError) -> AccessError: ...

    def get_invalid_account_type(self) -> InvalidAccountTypeError: ...

    def get_paper_access_denied(self) -> PaperAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AccessError_validator: bv.Validator = ...

class AuthError(bb.Union):
    invalid_access_token: AuthError = ...
    invalid_select_user: AuthError = ...
    invalid_select_admin: AuthError = ...
    user_suspended: AuthError = ...
    expired_access_token: AuthError = ...
    route_access_denied: AuthError = ...
    other: AuthError = ...

    def is_invalid_access_token(self) -> bool: ...

    def is_invalid_select_user(self) -> bool: ...

    def is_invalid_select_admin(self) -> bool: ...

    def is_user_suspended(self) -> bool: ...

    def is_expired_access_token(self) -> bool: ...

    def is_missing_scope(self) -> bool: ...

    def is_route_access_denied(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def missing_scope(cls, val: TokenScopeError) -> AuthError: ...

    def get_missing_scope(self) -> TokenScopeError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AuthError_validator: bv.Validator = ...

class InvalidAccountTypeError(bb.Union):
    endpoint: InvalidAccountTypeError = ...
    feature: InvalidAccountTypeError = ...
    other: InvalidAccountTypeError = ...

    def is_endpoint(self) -> bool: ...

    def is_feature(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

InvalidAccountTypeError_validator: bv.Validator = ...

class PaperAccessError(bb.Union):
    paper_disabled: PaperAccessError = ...
    not_paper_user: PaperAccessError = ...
    other: PaperAccessError = ...

    def is_paper_disabled(self) -> bool: ...

    def is_not_paper_user(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PaperAccessError_validator: bv.Validator = ...

class RateLimitError(bb.Struct):
    def __init__(self,
                 reason: RateLimitReason = ...,
                 retry_after: Optional[int] = ...) -> None: ...
    reason: bb.Attribute[RateLimitReason] = ...
    retry_after: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RateLimitError_validator: bv.Validator = ...

class RateLimitReason(bb.Union):
    too_many_requests: RateLimitReason = ...
    too_many_write_operations: RateLimitReason = ...
    other: RateLimitReason = ...

    def is_too_many_requests(self) -> bool: ...

    def is_too_many_write_operations(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RateLimitReason_validator: bv.Validator = ...

class TokenFromOAuth1Arg(bb.Struct):
    def __init__(self,
                 oauth1_token: Text = ...,
                 oauth1_token_secret: Text = ...) -> None: ...
    oauth1_token: bb.Attribute[Text] = ...
    oauth1_token_secret: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TokenFromOAuth1Arg_validator: bv.Validator = ...

class TokenFromOAuth1Error(bb.Union):
    invalid_oauth1_token_info: TokenFromOAuth1Error = ...
    app_id_mismatch: TokenFromOAuth1Error = ...
    other: TokenFromOAuth1Error = ...

    def is_invalid_oauth1_token_info(self) -> bool: ...

    def is_app_id_mismatch(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TokenFromOAuth1Error_validator: bv.Validator = ...

class TokenFromOAuth1Result(bb.Struct):
    def __init__(self,
                 oauth2_token: Text = ...) -> None: ...
    oauth2_token: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TokenFromOAuth1Result_validator: bv.Validator = ...

class TokenScopeError(bb.Struct):
    def __init__(self,
                 required_scope: Text = ...) -> None: ...
    required_scope: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TokenScopeError_validator: bv.Validator = ...

token_from_oauth1: bb.Route = ...
token_revoke: bb.Route = ...


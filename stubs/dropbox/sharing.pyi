# -*- coding: utf-8 -*-
# Auto-generated by Stone, do not modify.
# @generated
# flake8: noqa
# pylint: skip-file

from typing import (
    Callable,
    List,
    Optional,
    Text,
    Type,
    TypeVar,
)

import datetime
from stone.backends.python_rsrc import stone_base as bb  # type: ignore
from stone.backends.python_rsrc import stone_validators as bv  # type: ignore

from dropbox import async_  # type: ignore
from dropbox import common  # type: ignore
from dropbox import files  # type: ignore
from dropbox import seen_state  # type: ignore
from dropbox import team_common  # type: ignore
from dropbox import users  # type: ignore
from dropbox import users_common  # type: ignore

T = TypeVar('T', bound=bb.AnnotationType)
U = TypeVar('U')

class AccessInheritance(bb.Union):
    inherit: AccessInheritance = ...
    no_inherit: AccessInheritance = ...
    other: AccessInheritance = ...

    def is_inherit(self) -> bool: ...

    def is_no_inherit(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AccessInheritance_validator: bv.Validator = ...

class AccessLevel(bb.Union):
    owner: AccessLevel = ...
    editor: AccessLevel = ...
    viewer: AccessLevel = ...
    viewer_no_comment: AccessLevel = ...
    traverse: AccessLevel = ...
    other: AccessLevel = ...

    def is_owner(self) -> bool: ...

    def is_editor(self) -> bool: ...

    def is_viewer(self) -> bool: ...

    def is_viewer_no_comment(self) -> bool: ...

    def is_traverse(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AccessLevel_validator: bv.Validator = ...

class AclUpdatePolicy(bb.Union):
    owner: AclUpdatePolicy = ...
    editors: AclUpdatePolicy = ...
    other: AclUpdatePolicy = ...

    def is_owner(self) -> bool: ...

    def is_editors(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AclUpdatePolicy_validator: bv.Validator = ...

class AddFileMemberArgs(bb.Struct):
    def __init__(self,
                 file: Text = ...,
                 members: List[MemberSelector] = ...,
                 custom_message: Optional[Text] = ...,
                 quiet: Optional[bool] = ...,
                 access_level: Optional[AccessLevel] = ...,
                 add_message_as_comment: Optional[bool] = ...) -> None: ...
    file: bb.Attribute[Text] = ...
    members: bb.Attribute[List[MemberSelector]] = ...
    custom_message: bb.Attribute[Optional[Text]] = ...
    quiet: bb.Attribute[bool] = ...
    access_level: bb.Attribute[AccessLevel] = ...
    add_message_as_comment: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddFileMemberArgs_validator: bv.Validator = ...

class AddFileMemberError(bb.Union):
    rate_limit: AddFileMemberError = ...
    invalid_comment: AddFileMemberError = ...
    other: AddFileMemberError = ...

    def is_user_error(self) -> bool: ...

    def is_access_error(self) -> bool: ...

    def is_rate_limit(self) -> bool: ...

    def is_invalid_comment(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def user_error(cls, val: SharingUserError) -> AddFileMemberError: ...

    @classmethod
    def access_error(cls, val: SharingFileAccessError) -> AddFileMemberError: ...

    def get_user_error(self) -> SharingUserError: ...

    def get_access_error(self) -> SharingFileAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddFileMemberError_validator: bv.Validator = ...

class AddFolderMemberArg(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...,
                 members: List[AddMember] = ...,
                 quiet: Optional[bool] = ...,
                 custom_message: Optional[Text] = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    members: bb.Attribute[List[AddMember]] = ...
    quiet: bb.Attribute[bool] = ...
    custom_message: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddFolderMemberArg_validator: bv.Validator = ...

class AddFolderMemberError(bb.Union):
    email_unverified: AddFolderMemberError = ...
    banned_member: AddFolderMemberError = ...
    cant_share_outside_team: AddFolderMemberError = ...
    rate_limit: AddFolderMemberError = ...
    too_many_invitees: AddFolderMemberError = ...
    insufficient_plan: AddFolderMemberError = ...
    team_folder: AddFolderMemberError = ...
    no_permission: AddFolderMemberError = ...
    invalid_shared_folder: AddFolderMemberError = ...
    other: AddFolderMemberError = ...

    def is_access_error(self) -> bool: ...

    def is_email_unverified(self) -> bool: ...

    def is_banned_member(self) -> bool: ...

    def is_bad_member(self) -> bool: ...

    def is_cant_share_outside_team(self) -> bool: ...

    def is_too_many_members(self) -> bool: ...

    def is_too_many_pending_invites(self) -> bool: ...

    def is_rate_limit(self) -> bool: ...

    def is_too_many_invitees(self) -> bool: ...

    def is_insufficient_plan(self) -> bool: ...

    def is_team_folder(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_invalid_shared_folder(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharedFolderAccessError) -> AddFolderMemberError: ...

    @classmethod
    def bad_member(cls, val: AddMemberSelectorError) -> AddFolderMemberError: ...

    @classmethod
    def too_many_members(cls, val: int) -> AddFolderMemberError: ...

    @classmethod
    def too_many_pending_invites(cls, val: int) -> AddFolderMemberError: ...

    def get_access_error(self) -> SharedFolderAccessError: ...

    def get_bad_member(self) -> AddMemberSelectorError: ...

    def get_too_many_members(self) -> int: ...

    def get_too_many_pending_invites(self) -> int: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddFolderMemberError_validator: bv.Validator = ...

class AddMember(bb.Struct):
    def __init__(self,
                 member: MemberSelector = ...,
                 access_level: Optional[AccessLevel] = ...) -> None: ...
    member: bb.Attribute[MemberSelector] = ...
    access_level: bb.Attribute[AccessLevel] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddMember_validator: bv.Validator = ...

class AddMemberSelectorError(bb.Union):
    automatic_group: AddMemberSelectorError = ...
    group_deleted: AddMemberSelectorError = ...
    group_not_on_team: AddMemberSelectorError = ...
    other: AddMemberSelectorError = ...

    def is_automatic_group(self) -> bool: ...

    def is_invalid_dropbox_id(self) -> bool: ...

    def is_invalid_email(self) -> bool: ...

    def is_unverified_dropbox_id(self) -> bool: ...

    def is_group_deleted(self) -> bool: ...

    def is_group_not_on_team(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def invalid_dropbox_id(cls, val: Text) -> AddMemberSelectorError: ...

    @classmethod
    def invalid_email(cls, val: Text) -> AddMemberSelectorError: ...

    @classmethod
    def unverified_dropbox_id(cls, val: Text) -> AddMemberSelectorError: ...

    def get_invalid_dropbox_id(self) -> Text: ...

    def get_invalid_email(self) -> Text: ...

    def get_unverified_dropbox_id(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddMemberSelectorError_validator: bv.Validator = ...

class RequestedVisibility(bb.Union):
    public: RequestedVisibility = ...
    team_only: RequestedVisibility = ...
    password: RequestedVisibility = ...

    def is_public(self) -> bool: ...

    def is_team_only(self) -> bool: ...

    def is_password(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RequestedVisibility_validator: bv.Validator = ...

class ResolvedVisibility(RequestedVisibility):
    team_and_password: ResolvedVisibility = ...
    shared_folder_only: ResolvedVisibility = ...
    no_one: ResolvedVisibility = ...
    only_you: ResolvedVisibility = ...
    other: ResolvedVisibility = ...

    def is_team_and_password(self) -> bool: ...

    def is_shared_folder_only(self) -> bool: ...

    def is_no_one(self) -> bool: ...

    def is_only_you(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ResolvedVisibility_validator: bv.Validator = ...

class AlphaResolvedVisibility(ResolvedVisibility):
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AlphaResolvedVisibility_validator: bv.Validator = ...

class AudienceExceptionContentInfo(bb.Struct):
    def __init__(self,
                 name: Text = ...) -> None: ...
    name: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AudienceExceptionContentInfo_validator: bv.Validator = ...

class AudienceExceptions(bb.Struct):
    def __init__(self,
                 count: int = ...,
                 exceptions: List[AudienceExceptionContentInfo] = ...) -> None: ...
    count: bb.Attribute[int] = ...
    exceptions: bb.Attribute[List[AudienceExceptionContentInfo]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AudienceExceptions_validator: bv.Validator = ...

class AudienceRestrictingSharedFolder(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...,
                 name: Text = ...,
                 audience: LinkAudience = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    name: bb.Attribute[Text] = ...
    audience: bb.Attribute[LinkAudience] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AudienceRestrictingSharedFolder_validator: bv.Validator = ...

class LinkMetadata(bb.Struct):
    def __init__(self,
                 url: Text = ...,
                 visibility: Visibility = ...,
                 expires: Optional[datetime.datetime] = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    visibility: bb.Attribute[Visibility] = ...
    expires: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LinkMetadata_validator: bv.Validator = ...

class CollectionLinkMetadata(LinkMetadata):
    def __init__(self,
                 url: Text = ...,
                 visibility: Visibility = ...,
                 expires: Optional[datetime.datetime] = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    visibility: bb.Attribute[Visibility] = ...
    expires: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CollectionLinkMetadata_validator: bv.Validator = ...

class CreateSharedLinkArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 short_url: Optional[bool] = ...,
                 pending_upload: Optional[PendingUploadMode] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    short_url: bb.Attribute[bool] = ...
    pending_upload: bb.Attribute[Optional[PendingUploadMode]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateSharedLinkArg_validator: bv.Validator = ...

class CreateSharedLinkError(bb.Union):
    other: CreateSharedLinkError = ...

    def is_path(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: files.LookupError) -> CreateSharedLinkError: ...

    def get_path(self) -> files.LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateSharedLinkError_validator: bv.Validator = ...

class CreateSharedLinkWithSettingsArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 settings: Optional[SharedLinkSettings] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    settings: bb.Attribute[Optional[SharedLinkSettings]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateSharedLinkWithSettingsArg_validator: bv.Validator = ...

class CreateSharedLinkWithSettingsError(bb.Union):
    email_not_verified: CreateSharedLinkWithSettingsError = ...
    access_denied: CreateSharedLinkWithSettingsError = ...

    def is_path(self) -> bool: ...

    def is_email_not_verified(self) -> bool: ...

    def is_shared_link_already_exists(self) -> bool: ...

    def is_settings_error(self) -> bool: ...

    def is_access_denied(self) -> bool: ...

    @classmethod
    def path(cls, val: files.LookupError) -> CreateSharedLinkWithSettingsError: ...

    @classmethod
    def shared_link_already_exists(cls, val: Optional[SharedLinkAlreadyExistsMetadata]) -> CreateSharedLinkWithSettingsError: ...

    @classmethod
    def settings_error(cls, val: SharedLinkSettingsError) -> CreateSharedLinkWithSettingsError: ...

    def get_path(self) -> files.LookupError: ...

    def get_shared_link_already_exists(self) -> Optional[SharedLinkAlreadyExistsMetadata]: ...

    def get_settings_error(self) -> SharedLinkSettingsError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateSharedLinkWithSettingsError_validator: bv.Validator = ...

class SharedContentLinkMetadataBase(bb.Struct):
    def __init__(self,
                 audience_options: List[LinkAudience] = ...,
                 current_audience: LinkAudience = ...,
                 link_permissions: List[LinkPermission] = ...,
                 password_protected: bool = ...,
                 access_level: Optional[AccessLevel] = ...,
                 audience_restricting_shared_folder: Optional[AudienceRestrictingSharedFolder] = ...,
                 expiry: Optional[datetime.datetime] = ...) -> None: ...
    audience_options: bb.Attribute[List[LinkAudience]] = ...
    current_audience: bb.Attribute[LinkAudience] = ...
    link_permissions: bb.Attribute[List[LinkPermission]] = ...
    password_protected: bb.Attribute[bool] = ...
    access_level: bb.Attribute[Optional[AccessLevel]] = ...
    audience_restricting_shared_folder: bb.Attribute[Optional[AudienceRestrictingSharedFolder]] = ...
    expiry: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedContentLinkMetadataBase_validator: bv.Validator = ...

class ExpectedSharedContentLinkMetadata(SharedContentLinkMetadataBase):
    def __init__(self,
                 audience_options: List[LinkAudience] = ...,
                 current_audience: LinkAudience = ...,
                 link_permissions: List[LinkPermission] = ...,
                 password_protected: bool = ...,
                 access_level: Optional[AccessLevel] = ...,
                 audience_restricting_shared_folder: Optional[AudienceRestrictingSharedFolder] = ...,
                 expiry: Optional[datetime.datetime] = ...) -> None: ...
    audience_options: bb.Attribute[List[LinkAudience]] = ...
    current_audience: bb.Attribute[LinkAudience] = ...
    link_permissions: bb.Attribute[List[LinkPermission]] = ...
    password_protected: bb.Attribute[bool] = ...
    access_level: bb.Attribute[Optional[AccessLevel]] = ...
    audience_restricting_shared_folder: bb.Attribute[Optional[AudienceRestrictingSharedFolder]] = ...
    expiry: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExpectedSharedContentLinkMetadata_validator: bv.Validator = ...

class FileAction(bb.Union):
    disable_viewer_info: FileAction = ...
    edit_contents: FileAction = ...
    enable_viewer_info: FileAction = ...
    invite_viewer: FileAction = ...
    invite_viewer_no_comment: FileAction = ...
    invite_editor: FileAction = ...
    unshare: FileAction = ...
    relinquish_membership: FileAction = ...
    share_link: FileAction = ...
    create_link: FileAction = ...
    create_view_link: FileAction = ...
    create_edit_link: FileAction = ...
    other: FileAction = ...

    def is_disable_viewer_info(self) -> bool: ...

    def is_edit_contents(self) -> bool: ...

    def is_enable_viewer_info(self) -> bool: ...

    def is_invite_viewer(self) -> bool: ...

    def is_invite_viewer_no_comment(self) -> bool: ...

    def is_invite_editor(self) -> bool: ...

    def is_unshare(self) -> bool: ...

    def is_relinquish_membership(self) -> bool: ...

    def is_share_link(self) -> bool: ...

    def is_create_link(self) -> bool: ...

    def is_create_view_link(self) -> bool: ...

    def is_create_edit_link(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileAction_validator: bv.Validator = ...

class FileErrorResult(bb.Union):
    other: FileErrorResult = ...

    def is_file_not_found_error(self) -> bool: ...

    def is_invalid_file_action_error(self) -> bool: ...

    def is_permission_denied_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def file_not_found_error(cls, val: Text) -> FileErrorResult: ...

    @classmethod
    def invalid_file_action_error(cls, val: Text) -> FileErrorResult: ...

    @classmethod
    def permission_denied_error(cls, val: Text) -> FileErrorResult: ...

    def get_file_not_found_error(self) -> Text: ...

    def get_invalid_file_action_error(self) -> Text: ...

    def get_permission_denied_error(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileErrorResult_validator: bv.Validator = ...

class SharedLinkMetadata(bb.Struct):
    def __init__(self,
                 url: Text = ...,
                 name: Text = ...,
                 link_permissions: LinkPermissions = ...,
                 id: Optional[Text] = ...,
                 expires: Optional[datetime.datetime] = ...,
                 path_lower: Optional[Text] = ...,
                 team_member_info: Optional[TeamMemberInfo] = ...,
                 content_owner_team_info: Optional[users.Team] = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    name: bb.Attribute[Text] = ...
    link_permissions: bb.Attribute[LinkPermissions] = ...
    id: bb.Attribute[Optional[Text]] = ...
    expires: bb.Attribute[Optional[datetime.datetime]] = ...
    path_lower: bb.Attribute[Optional[Text]] = ...
    team_member_info: bb.Attribute[Optional[TeamMemberInfo]] = ...
    content_owner_team_info: bb.Attribute[Optional[users.Team]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedLinkMetadata_validator: bv.Validator = ...

class FileLinkMetadata(SharedLinkMetadata):
    def __init__(self,
                 url: Text = ...,
                 name: Text = ...,
                 link_permissions: LinkPermissions = ...,
                 client_modified: datetime.datetime = ...,
                 server_modified: datetime.datetime = ...,
                 rev: Text = ...,
                 size: int = ...,
                 id: Optional[Text] = ...,
                 expires: Optional[datetime.datetime] = ...,
                 path_lower: Optional[Text] = ...,
                 team_member_info: Optional[TeamMemberInfo] = ...,
                 content_owner_team_info: Optional[users.Team] = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    name: bb.Attribute[Text] = ...
    link_permissions: bb.Attribute[LinkPermissions] = ...
    client_modified: bb.Attribute[datetime.datetime] = ...
    server_modified: bb.Attribute[datetime.datetime] = ...
    rev: bb.Attribute[Text] = ...
    size: bb.Attribute[int] = ...
    id: bb.Attribute[Optional[Text]] = ...
    expires: bb.Attribute[Optional[datetime.datetime]] = ...
    path_lower: bb.Attribute[Optional[Text]] = ...
    team_member_info: bb.Attribute[Optional[TeamMemberInfo]] = ...
    content_owner_team_info: bb.Attribute[Optional[users.Team]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileLinkMetadata_validator: bv.Validator = ...

class FileMemberActionError(bb.Union):
    invalid_member: FileMemberActionError = ...
    no_permission: FileMemberActionError = ...
    other: FileMemberActionError = ...

    def is_invalid_member(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_access_error(self) -> bool: ...

    def is_no_explicit_access(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharingFileAccessError) -> FileMemberActionError: ...

    @classmethod
    def no_explicit_access(cls, val: MemberAccessLevelResult) -> FileMemberActionError: ...

    def get_access_error(self) -> SharingFileAccessError: ...

    def get_no_explicit_access(self) -> MemberAccessLevelResult: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileMemberActionError_validator: bv.Validator = ...

class FileMemberActionIndividualResult(bb.Union):
    def is_success(self) -> bool: ...

    def is_member_error(self) -> bool: ...

    @classmethod
    def success(cls, val: Optional[AccessLevel]) -> FileMemberActionIndividualResult: ...

    @classmethod
    def member_error(cls, val: FileMemberActionError) -> FileMemberActionIndividualResult: ...

    def get_success(self) -> Optional[AccessLevel]: ...

    def get_member_error(self) -> FileMemberActionError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileMemberActionIndividualResult_validator: bv.Validator = ...

class FileMemberActionResult(bb.Struct):
    def __init__(self,
                 member: MemberSelector = ...,
                 result: FileMemberActionIndividualResult = ...) -> None: ...
    member: bb.Attribute[MemberSelector] = ...
    result: bb.Attribute[FileMemberActionIndividualResult] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileMemberActionResult_validator: bv.Validator = ...

class FileMemberRemoveActionResult(bb.Union):
    other: FileMemberRemoveActionResult = ...

    def is_success(self) -> bool: ...

    def is_member_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: MemberAccessLevelResult) -> FileMemberRemoveActionResult: ...

    @classmethod
    def member_error(cls, val: FileMemberActionError) -> FileMemberRemoveActionResult: ...

    def get_success(self) -> MemberAccessLevelResult: ...

    def get_member_error(self) -> FileMemberActionError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileMemberRemoveActionResult_validator: bv.Validator = ...

class FilePermission(bb.Struct):
    def __init__(self,
                 action: FileAction = ...,
                 allow: bool = ...,
                 reason: Optional[PermissionDeniedReason] = ...) -> None: ...
    action: bb.Attribute[FileAction] = ...
    allow: bb.Attribute[bool] = ...
    reason: bb.Attribute[Optional[PermissionDeniedReason]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FilePermission_validator: bv.Validator = ...

class FolderAction(bb.Union):
    change_options: FolderAction = ...
    disable_viewer_info: FolderAction = ...
    edit_contents: FolderAction = ...
    enable_viewer_info: FolderAction = ...
    invite_editor: FolderAction = ...
    invite_viewer: FolderAction = ...
    invite_viewer_no_comment: FolderAction = ...
    relinquish_membership: FolderAction = ...
    unmount: FolderAction = ...
    unshare: FolderAction = ...
    leave_a_copy: FolderAction = ...
    share_link: FolderAction = ...
    create_link: FolderAction = ...
    set_access_inheritance: FolderAction = ...
    other: FolderAction = ...

    def is_change_options(self) -> bool: ...

    def is_disable_viewer_info(self) -> bool: ...

    def is_edit_contents(self) -> bool: ...

    def is_enable_viewer_info(self) -> bool: ...

    def is_invite_editor(self) -> bool: ...

    def is_invite_viewer(self) -> bool: ...

    def is_invite_viewer_no_comment(self) -> bool: ...

    def is_relinquish_membership(self) -> bool: ...

    def is_unmount(self) -> bool: ...

    def is_unshare(self) -> bool: ...

    def is_leave_a_copy(self) -> bool: ...

    def is_share_link(self) -> bool: ...

    def is_create_link(self) -> bool: ...

    def is_set_access_inheritance(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FolderAction_validator: bv.Validator = ...

class FolderLinkMetadata(SharedLinkMetadata):
    def __init__(self,
                 url: Text = ...,
                 name: Text = ...,
                 link_permissions: LinkPermissions = ...,
                 id: Optional[Text] = ...,
                 expires: Optional[datetime.datetime] = ...,
                 path_lower: Optional[Text] = ...,
                 team_member_info: Optional[TeamMemberInfo] = ...,
                 content_owner_team_info: Optional[users.Team] = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    name: bb.Attribute[Text] = ...
    link_permissions: bb.Attribute[LinkPermissions] = ...
    id: bb.Attribute[Optional[Text]] = ...
    expires: bb.Attribute[Optional[datetime.datetime]] = ...
    path_lower: bb.Attribute[Optional[Text]] = ...
    team_member_info: bb.Attribute[Optional[TeamMemberInfo]] = ...
    content_owner_team_info: bb.Attribute[Optional[users.Team]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FolderLinkMetadata_validator: bv.Validator = ...

class FolderPermission(bb.Struct):
    def __init__(self,
                 action: FolderAction = ...,
                 allow: bool = ...,
                 reason: Optional[PermissionDeniedReason] = ...) -> None: ...
    action: bb.Attribute[FolderAction] = ...
    allow: bb.Attribute[bool] = ...
    reason: bb.Attribute[Optional[PermissionDeniedReason]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FolderPermission_validator: bv.Validator = ...

class FolderPolicy(bb.Struct):
    def __init__(self,
                 acl_update_policy: AclUpdatePolicy = ...,
                 shared_link_policy: SharedLinkPolicy = ...,
                 member_policy: Optional[MemberPolicy] = ...,
                 resolved_member_policy: Optional[MemberPolicy] = ...,
                 viewer_info_policy: Optional[ViewerInfoPolicy] = ...) -> None: ...
    acl_update_policy: bb.Attribute[AclUpdatePolicy] = ...
    shared_link_policy: bb.Attribute[SharedLinkPolicy] = ...
    member_policy: bb.Attribute[Optional[MemberPolicy]] = ...
    resolved_member_policy: bb.Attribute[Optional[MemberPolicy]] = ...
    viewer_info_policy: bb.Attribute[Optional[ViewerInfoPolicy]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FolderPolicy_validator: bv.Validator = ...

class GetFileMetadataArg(bb.Struct):
    def __init__(self,
                 file: Text = ...,
                 actions: Optional[List[FileAction]] = ...) -> None: ...
    file: bb.Attribute[Text] = ...
    actions: bb.Attribute[Optional[List[FileAction]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetFileMetadataArg_validator: bv.Validator = ...

class GetFileMetadataBatchArg(bb.Struct):
    def __init__(self,
                 files: List[Text] = ...,
                 actions: Optional[List[FileAction]] = ...) -> None: ...
    files: bb.Attribute[List[Text]] = ...
    actions: bb.Attribute[Optional[List[FileAction]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetFileMetadataBatchArg_validator: bv.Validator = ...

class GetFileMetadataBatchResult(bb.Struct):
    def __init__(self,
                 file: Text = ...,
                 result: GetFileMetadataIndividualResult = ...) -> None: ...
    file: bb.Attribute[Text] = ...
    result: bb.Attribute[GetFileMetadataIndividualResult] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetFileMetadataBatchResult_validator: bv.Validator = ...

class GetFileMetadataError(bb.Union):
    other: GetFileMetadataError = ...

    def is_user_error(self) -> bool: ...

    def is_access_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def user_error(cls, val: SharingUserError) -> GetFileMetadataError: ...

    @classmethod
    def access_error(cls, val: SharingFileAccessError) -> GetFileMetadataError: ...

    def get_user_error(self) -> SharingUserError: ...

    def get_access_error(self) -> SharingFileAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetFileMetadataError_validator: bv.Validator = ...

class GetFileMetadataIndividualResult(bb.Union):
    other: GetFileMetadataIndividualResult = ...

    def is_metadata(self) -> bool: ...

    def is_access_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def metadata(cls, val: SharedFileMetadata) -> GetFileMetadataIndividualResult: ...

    @classmethod
    def access_error(cls, val: SharingFileAccessError) -> GetFileMetadataIndividualResult: ...

    def get_metadata(self) -> SharedFileMetadata: ...

    def get_access_error(self) -> SharingFileAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetFileMetadataIndividualResult_validator: bv.Validator = ...

class GetMetadataArgs(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...,
                 actions: Optional[List[FolderAction]] = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    actions: bb.Attribute[Optional[List[FolderAction]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetMetadataArgs_validator: bv.Validator = ...

class SharedLinkError(bb.Union):
    shared_link_not_found: SharedLinkError = ...
    shared_link_access_denied: SharedLinkError = ...
    unsupported_link_type: SharedLinkError = ...
    other: SharedLinkError = ...

    def is_shared_link_not_found(self) -> bool: ...

    def is_shared_link_access_denied(self) -> bool: ...

    def is_unsupported_link_type(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedLinkError_validator: bv.Validator = ...

class GetSharedLinkFileError(SharedLinkError):
    shared_link_is_directory: GetSharedLinkFileError = ...

    def is_shared_link_is_directory(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetSharedLinkFileError_validator: bv.Validator = ...

class GetSharedLinkMetadataArg(bb.Struct):
    def __init__(self,
                 url: Text = ...,
                 path: Optional[Text] = ...,
                 link_password: Optional[Text] = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    path: bb.Attribute[Optional[Text]] = ...
    link_password: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetSharedLinkMetadataArg_validator: bv.Validator = ...

class GetSharedLinksArg(bb.Struct):
    def __init__(self,
                 path: Optional[Text] = ...) -> None: ...
    path: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetSharedLinksArg_validator: bv.Validator = ...

class GetSharedLinksError(bb.Union):
    other: GetSharedLinksError = ...

    def is_path(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: Optional[Text]) -> GetSharedLinksError: ...

    def get_path(self) -> Optional[Text]: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetSharedLinksError_validator: bv.Validator = ...

class GetSharedLinksResult(bb.Struct):
    def __init__(self,
                 links: List[LinkMetadata] = ...) -> None: ...
    links: bb.Attribute[List[LinkMetadata]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetSharedLinksResult_validator: bv.Validator = ...

class GroupInfo(team_common.GroupSummary):
    def __init__(self,
                 group_name: Text = ...,
                 group_id: Text = ...,
                 group_management_type: team_common.GroupManagementType = ...,
                 group_type: team_common.GroupType = ...,
                 is_member: bool = ...,
                 is_owner: bool = ...,
                 same_team: bool = ...,
                 group_external_id: Optional[Text] = ...,
                 member_count: Optional[int] = ...) -> None: ...
    group_name: bb.Attribute[Text] = ...
    group_id: bb.Attribute[Text] = ...
    group_management_type: bb.Attribute[team_common.GroupManagementType] = ...
    group_type: bb.Attribute[team_common.GroupType] = ...
    is_member: bb.Attribute[bool] = ...
    is_owner: bb.Attribute[bool] = ...
    same_team: bb.Attribute[bool] = ...
    group_external_id: bb.Attribute[Optional[Text]] = ...
    member_count: bb.Attribute[Optional[int]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupInfo_validator: bv.Validator = ...

class MembershipInfo(bb.Struct):
    def __init__(self,
                 access_type: AccessLevel = ...,
                 permissions: Optional[List[MemberPermission]] = ...,
                 initials: Optional[Text] = ...,
                 is_inherited: Optional[bool] = ...) -> None: ...
    access_type: bb.Attribute[AccessLevel] = ...
    permissions: bb.Attribute[Optional[List[MemberPermission]]] = ...
    initials: bb.Attribute[Optional[Text]] = ...
    is_inherited: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MembershipInfo_validator: bv.Validator = ...

class GroupMembershipInfo(MembershipInfo):
    def __init__(self,
                 access_type: AccessLevel = ...,
                 group: GroupInfo = ...,
                 permissions: Optional[List[MemberPermission]] = ...,
                 initials: Optional[Text] = ...,
                 is_inherited: Optional[bool] = ...) -> None: ...
    access_type: bb.Attribute[AccessLevel] = ...
    group: bb.Attribute[GroupInfo] = ...
    permissions: bb.Attribute[Optional[List[MemberPermission]]] = ...
    initials: bb.Attribute[Optional[Text]] = ...
    is_inherited: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GroupMembershipInfo_validator: bv.Validator = ...

class InsufficientPlan(bb.Struct):
    def __init__(self,
                 message: Text = ...,
                 upsell_url: Optional[Text] = ...) -> None: ...
    message: bb.Attribute[Text] = ...
    upsell_url: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

InsufficientPlan_validator: bv.Validator = ...

class InsufficientQuotaAmounts(bb.Struct):
    def __init__(self,
                 space_needed: int = ...,
                 space_shortage: int = ...,
                 space_left: int = ...) -> None: ...
    space_needed: bb.Attribute[int] = ...
    space_shortage: bb.Attribute[int] = ...
    space_left: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

InsufficientQuotaAmounts_validator: bv.Validator = ...

class InviteeInfo(bb.Union):
    other: InviteeInfo = ...

    def is_email(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def email(cls, val: Text) -> InviteeInfo: ...

    def get_email(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

InviteeInfo_validator: bv.Validator = ...

class InviteeMembershipInfo(MembershipInfo):
    def __init__(self,
                 access_type: AccessLevel = ...,
                 invitee: InviteeInfo = ...,
                 permissions: Optional[List[MemberPermission]] = ...,
                 initials: Optional[Text] = ...,
                 is_inherited: Optional[bool] = ...,
                 user: Optional[UserInfo] = ...) -> None: ...
    access_type: bb.Attribute[AccessLevel] = ...
    invitee: bb.Attribute[InviteeInfo] = ...
    permissions: bb.Attribute[Optional[List[MemberPermission]]] = ...
    initials: bb.Attribute[Optional[Text]] = ...
    is_inherited: bb.Attribute[bool] = ...
    user: bb.Attribute[Optional[UserInfo]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

InviteeMembershipInfo_validator: bv.Validator = ...

class JobError(bb.Union):
    other: JobError = ...

    def is_unshare_folder_error(self) -> bool: ...

    def is_remove_folder_member_error(self) -> bool: ...

    def is_relinquish_folder_membership_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def unshare_folder_error(cls, val: UnshareFolderError) -> JobError: ...

    @classmethod
    def remove_folder_member_error(cls, val: RemoveFolderMemberError) -> JobError: ...

    @classmethod
    def relinquish_folder_membership_error(cls, val: RelinquishFolderMembershipError) -> JobError: ...

    def get_unshare_folder_error(self) -> UnshareFolderError: ...

    def get_remove_folder_member_error(self) -> RemoveFolderMemberError: ...

    def get_relinquish_folder_membership_error(self) -> RelinquishFolderMembershipError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

JobError_validator: bv.Validator = ...

class JobStatus(async_.PollResultBase):
    complete: JobStatus = ...

    def is_complete(self) -> bool: ...

    def is_failed(self) -> bool: ...

    @classmethod
    def failed(cls, val: JobError) -> JobStatus: ...

    def get_failed(self) -> JobError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

JobStatus_validator: bv.Validator = ...

class LinkAccessLevel(bb.Union):
    viewer: LinkAccessLevel = ...
    editor: LinkAccessLevel = ...
    other: LinkAccessLevel = ...

    def is_viewer(self) -> bool: ...

    def is_editor(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LinkAccessLevel_validator: bv.Validator = ...

class LinkAction(bb.Union):
    change_access_level: LinkAction = ...
    change_audience: LinkAction = ...
    remove_expiry: LinkAction = ...
    remove_password: LinkAction = ...
    set_expiry: LinkAction = ...
    set_password: LinkAction = ...
    other: LinkAction = ...

    def is_change_access_level(self) -> bool: ...

    def is_change_audience(self) -> bool: ...

    def is_remove_expiry(self) -> bool: ...

    def is_remove_password(self) -> bool: ...

    def is_set_expiry(self) -> bool: ...

    def is_set_password(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LinkAction_validator: bv.Validator = ...

class LinkAudience(bb.Union):
    public: LinkAudience = ...
    team: LinkAudience = ...
    no_one: LinkAudience = ...
    password: LinkAudience = ...
    members: LinkAudience = ...
    other: LinkAudience = ...

    def is_public(self) -> bool: ...

    def is_team(self) -> bool: ...

    def is_no_one(self) -> bool: ...

    def is_password(self) -> bool: ...

    def is_members(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LinkAudience_validator: bv.Validator = ...

class VisibilityPolicyDisallowedReason(bb.Union):
    delete_and_recreate: VisibilityPolicyDisallowedReason = ...
    restricted_by_shared_folder: VisibilityPolicyDisallowedReason = ...
    restricted_by_team: VisibilityPolicyDisallowedReason = ...
    user_not_on_team: VisibilityPolicyDisallowedReason = ...
    user_account_type: VisibilityPolicyDisallowedReason = ...
    permission_denied: VisibilityPolicyDisallowedReason = ...
    other: VisibilityPolicyDisallowedReason = ...

    def is_delete_and_recreate(self) -> bool: ...

    def is_restricted_by_shared_folder(self) -> bool: ...

    def is_restricted_by_team(self) -> bool: ...

    def is_user_not_on_team(self) -> bool: ...

    def is_user_account_type(self) -> bool: ...

    def is_permission_denied(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

VisibilityPolicyDisallowedReason_validator: bv.Validator = ...

class LinkAudienceDisallowedReason(VisibilityPolicyDisallowedReason):
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LinkAudienceDisallowedReason_validator: bv.Validator = ...

class LinkAudienceOption(bb.Struct):
    def __init__(self,
                 audience: LinkAudience = ...,
                 allowed: bool = ...,
                 disallowed_reason: Optional[LinkAudienceDisallowedReason] = ...) -> None: ...
    audience: bb.Attribute[LinkAudience] = ...
    allowed: bb.Attribute[bool] = ...
    disallowed_reason: bb.Attribute[Optional[LinkAudienceDisallowedReason]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LinkAudienceOption_validator: bv.Validator = ...

class LinkExpiry(bb.Union):
    remove_expiry: LinkExpiry = ...
    other: LinkExpiry = ...

    def is_remove_expiry(self) -> bool: ...

    def is_set_expiry(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def set_expiry(cls, val: datetime.datetime) -> LinkExpiry: ...

    def get_set_expiry(self) -> datetime.datetime: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LinkExpiry_validator: bv.Validator = ...

class LinkPassword(bb.Union):
    remove_password: LinkPassword = ...
    other: LinkPassword = ...

    def is_remove_password(self) -> bool: ...

    def is_set_password(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def set_password(cls, val: Text) -> LinkPassword: ...

    def get_set_password(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LinkPassword_validator: bv.Validator = ...

class LinkPermission(bb.Struct):
    def __init__(self,
                 action: LinkAction = ...,
                 allow: bool = ...,
                 reason: Optional[PermissionDeniedReason] = ...) -> None: ...
    action: bb.Attribute[LinkAction] = ...
    allow: bb.Attribute[bool] = ...
    reason: bb.Attribute[Optional[PermissionDeniedReason]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LinkPermission_validator: bv.Validator = ...

class LinkPermissions(bb.Struct):
    def __init__(self,
                 can_revoke: bool = ...,
                 visibility_policies: List[VisibilityPolicy] = ...,
                 can_set_expiry: bool = ...,
                 can_remove_expiry: bool = ...,
                 allow_download: bool = ...,
                 can_allow_download: bool = ...,
                 can_disallow_download: bool = ...,
                 allow_comments: bool = ...,
                 team_restricts_comments: bool = ...,
                 resolved_visibility: Optional[ResolvedVisibility] = ...,
                 requested_visibility: Optional[RequestedVisibility] = ...,
                 revoke_failure_reason: Optional[SharedLinkAccessFailureReason] = ...,
                 effective_audience: Optional[LinkAudience] = ...,
                 link_access_level: Optional[LinkAccessLevel] = ...,
                 audience_options: Optional[List[LinkAudienceOption]] = ...,
                 can_set_password: Optional[bool] = ...,
                 can_remove_password: Optional[bool] = ...,
                 require_password: Optional[bool] = ...,
                 can_use_extended_sharing_controls: Optional[bool] = ...) -> None: ...
    can_revoke: bb.Attribute[bool] = ...
    visibility_policies: bb.Attribute[List[VisibilityPolicy]] = ...
    can_set_expiry: bb.Attribute[bool] = ...
    can_remove_expiry: bb.Attribute[bool] = ...
    allow_download: bb.Attribute[bool] = ...
    can_allow_download: bb.Attribute[bool] = ...
    can_disallow_download: bb.Attribute[bool] = ...
    allow_comments: bb.Attribute[bool] = ...
    team_restricts_comments: bb.Attribute[bool] = ...
    resolved_visibility: bb.Attribute[Optional[ResolvedVisibility]] = ...
    requested_visibility: bb.Attribute[Optional[RequestedVisibility]] = ...
    revoke_failure_reason: bb.Attribute[Optional[SharedLinkAccessFailureReason]] = ...
    effective_audience: bb.Attribute[Optional[LinkAudience]] = ...
    link_access_level: bb.Attribute[Optional[LinkAccessLevel]] = ...
    audience_options: bb.Attribute[Optional[List[LinkAudienceOption]]] = ...
    can_set_password: bb.Attribute[Optional[bool]] = ...
    can_remove_password: bb.Attribute[Optional[bool]] = ...
    require_password: bb.Attribute[Optional[bool]] = ...
    can_use_extended_sharing_controls: bb.Attribute[Optional[bool]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LinkPermissions_validator: bv.Validator = ...

class LinkSettings(bb.Struct):
    def __init__(self,
                 access_level: Optional[AccessLevel] = ...,
                 audience: Optional[LinkAudience] = ...,
                 expiry: Optional[LinkExpiry] = ...,
                 password: Optional[LinkPassword] = ...) -> None: ...
    access_level: bb.Attribute[Optional[AccessLevel]] = ...
    audience: bb.Attribute[Optional[LinkAudience]] = ...
    expiry: bb.Attribute[Optional[LinkExpiry]] = ...
    password: bb.Attribute[Optional[LinkPassword]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LinkSettings_validator: bv.Validator = ...

class ListFileMembersArg(bb.Struct):
    def __init__(self,
                 file: Text = ...,
                 actions: Optional[List[MemberAction]] = ...,
                 include_inherited: Optional[bool] = ...,
                 limit: Optional[int] = ...) -> None: ...
    file: bb.Attribute[Text] = ...
    actions: bb.Attribute[Optional[List[MemberAction]]] = ...
    include_inherited: bb.Attribute[bool] = ...
    limit: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFileMembersArg_validator: bv.Validator = ...

class ListFileMembersBatchArg(bb.Struct):
    def __init__(self,
                 files: List[Text] = ...,
                 limit: Optional[int] = ...) -> None: ...
    files: bb.Attribute[List[Text]] = ...
    limit: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFileMembersBatchArg_validator: bv.Validator = ...

class ListFileMembersBatchResult(bb.Struct):
    def __init__(self,
                 file: Text = ...,
                 result: ListFileMembersIndividualResult = ...) -> None: ...
    file: bb.Attribute[Text] = ...
    result: bb.Attribute[ListFileMembersIndividualResult] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFileMembersBatchResult_validator: bv.Validator = ...

class ListFileMembersContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFileMembersContinueArg_validator: bv.Validator = ...

class ListFileMembersContinueError(bb.Union):
    invalid_cursor: ListFileMembersContinueError = ...
    other: ListFileMembersContinueError = ...

    def is_user_error(self) -> bool: ...

    def is_access_error(self) -> bool: ...

    def is_invalid_cursor(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def user_error(cls, val: SharingUserError) -> ListFileMembersContinueError: ...

    @classmethod
    def access_error(cls, val: SharingFileAccessError) -> ListFileMembersContinueError: ...

    def get_user_error(self) -> SharingUserError: ...

    def get_access_error(self) -> SharingFileAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFileMembersContinueError_validator: bv.Validator = ...

class ListFileMembersCountResult(bb.Struct):
    def __init__(self,
                 members: SharedFileMembers = ...,
                 member_count: int = ...) -> None: ...
    members: bb.Attribute[SharedFileMembers] = ...
    member_count: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFileMembersCountResult_validator: bv.Validator = ...

class ListFileMembersError(bb.Union):
    other: ListFileMembersError = ...

    def is_user_error(self) -> bool: ...

    def is_access_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def user_error(cls, val: SharingUserError) -> ListFileMembersError: ...

    @classmethod
    def access_error(cls, val: SharingFileAccessError) -> ListFileMembersError: ...

    def get_user_error(self) -> SharingUserError: ...

    def get_access_error(self) -> SharingFileAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFileMembersError_validator: bv.Validator = ...

class ListFileMembersIndividualResult(bb.Union):
    other: ListFileMembersIndividualResult = ...

    def is_result(self) -> bool: ...

    def is_access_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def result(cls, val: ListFileMembersCountResult) -> ListFileMembersIndividualResult: ...

    @classmethod
    def access_error(cls, val: SharingFileAccessError) -> ListFileMembersIndividualResult: ...

    def get_result(self) -> ListFileMembersCountResult: ...

    def get_access_error(self) -> SharingFileAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFileMembersIndividualResult_validator: bv.Validator = ...

class ListFilesArg(bb.Struct):
    def __init__(self,
                 limit: Optional[int] = ...,
                 actions: Optional[List[FileAction]] = ...) -> None: ...
    limit: bb.Attribute[int] = ...
    actions: bb.Attribute[Optional[List[FileAction]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFilesArg_validator: bv.Validator = ...

class ListFilesContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFilesContinueArg_validator: bv.Validator = ...

class ListFilesContinueError(bb.Union):
    invalid_cursor: ListFilesContinueError = ...
    other: ListFilesContinueError = ...

    def is_user_error(self) -> bool: ...

    def is_invalid_cursor(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def user_error(cls, val: SharingUserError) -> ListFilesContinueError: ...

    def get_user_error(self) -> SharingUserError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFilesContinueError_validator: bv.Validator = ...

class ListFilesResult(bb.Struct):
    def __init__(self,
                 entries: List[SharedFileMetadata] = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    entries: bb.Attribute[List[SharedFileMetadata]] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFilesResult_validator: bv.Validator = ...

class ListFolderMembersCursorArg(bb.Struct):
    def __init__(self,
                 actions: Optional[List[MemberAction]] = ...,
                 limit: Optional[int] = ...) -> None: ...
    actions: bb.Attribute[Optional[List[MemberAction]]] = ...
    limit: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderMembersCursorArg_validator: bv.Validator = ...

class ListFolderMembersArgs(ListFolderMembersCursorArg):
    def __init__(self,
                 shared_folder_id: Text = ...,
                 actions: Optional[List[MemberAction]] = ...,
                 limit: Optional[int] = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    actions: bb.Attribute[Optional[List[MemberAction]]] = ...
    limit: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderMembersArgs_validator: bv.Validator = ...

class ListFolderMembersContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderMembersContinueArg_validator: bv.Validator = ...

class ListFolderMembersContinueError(bb.Union):
    invalid_cursor: ListFolderMembersContinueError = ...
    other: ListFolderMembersContinueError = ...

    def is_access_error(self) -> bool: ...

    def is_invalid_cursor(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharedFolderAccessError) -> ListFolderMembersContinueError: ...

    def get_access_error(self) -> SharedFolderAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderMembersContinueError_validator: bv.Validator = ...

class ListFoldersArgs(bb.Struct):
    def __init__(self,
                 limit: Optional[int] = ...,
                 actions: Optional[List[FolderAction]] = ...) -> None: ...
    limit: bb.Attribute[int] = ...
    actions: bb.Attribute[Optional[List[FolderAction]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFoldersArgs_validator: bv.Validator = ...

class ListFoldersContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFoldersContinueArg_validator: bv.Validator = ...

class ListFoldersContinueError(bb.Union):
    invalid_cursor: ListFoldersContinueError = ...
    other: ListFoldersContinueError = ...

    def is_invalid_cursor(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFoldersContinueError_validator: bv.Validator = ...

class ListFoldersResult(bb.Struct):
    def __init__(self,
                 entries: List[SharedFolderMetadata] = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    entries: bb.Attribute[List[SharedFolderMetadata]] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFoldersResult_validator: bv.Validator = ...

class ListSharedLinksArg(bb.Struct):
    def __init__(self,
                 path: Optional[Text] = ...,
                 cursor: Optional[Text] = ...,
                 direct_only: Optional[bool] = ...) -> None: ...
    path: bb.Attribute[Optional[Text]] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    direct_only: bb.Attribute[Optional[bool]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListSharedLinksArg_validator: bv.Validator = ...

class ListSharedLinksError(bb.Union):
    reset: ListSharedLinksError = ...
    other: ListSharedLinksError = ...

    def is_path(self) -> bool: ...

    def is_reset(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: files.LookupError) -> ListSharedLinksError: ...

    def get_path(self) -> files.LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListSharedLinksError_validator: bv.Validator = ...

class ListSharedLinksResult(bb.Struct):
    def __init__(self,
                 links: List[SharedLinkMetadata] = ...,
                 has_more: bool = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    links: bb.Attribute[List[SharedLinkMetadata]] = ...
    has_more: bb.Attribute[bool] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListSharedLinksResult_validator: bv.Validator = ...

class MemberAccessLevelResult(bb.Struct):
    def __init__(self,
                 access_level: Optional[AccessLevel] = ...,
                 warning: Optional[Text] = ...,
                 access_details: Optional[List[ParentFolderAccessInfo]] = ...) -> None: ...
    access_level: bb.Attribute[Optional[AccessLevel]] = ...
    warning: bb.Attribute[Optional[Text]] = ...
    access_details: bb.Attribute[Optional[List[ParentFolderAccessInfo]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberAccessLevelResult_validator: bv.Validator = ...

class MemberAction(bb.Union):
    leave_a_copy: MemberAction = ...
    make_editor: MemberAction = ...
    make_owner: MemberAction = ...
    make_viewer: MemberAction = ...
    make_viewer_no_comment: MemberAction = ...
    remove: MemberAction = ...
    other: MemberAction = ...

    def is_leave_a_copy(self) -> bool: ...

    def is_make_editor(self) -> bool: ...

    def is_make_owner(self) -> bool: ...

    def is_make_viewer(self) -> bool: ...

    def is_make_viewer_no_comment(self) -> bool: ...

    def is_remove(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberAction_validator: bv.Validator = ...

class MemberPermission(bb.Struct):
    def __init__(self,
                 action: MemberAction = ...,
                 allow: bool = ...,
                 reason: Optional[PermissionDeniedReason] = ...) -> None: ...
    action: bb.Attribute[MemberAction] = ...
    allow: bb.Attribute[bool] = ...
    reason: bb.Attribute[Optional[PermissionDeniedReason]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberPermission_validator: bv.Validator = ...

class MemberPolicy(bb.Union):
    team: MemberPolicy = ...
    anyone: MemberPolicy = ...
    other: MemberPolicy = ...

    def is_team(self) -> bool: ...

    def is_anyone(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberPolicy_validator: bv.Validator = ...

class MemberSelector(bb.Union):
    other: MemberSelector = ...

    def is_dropbox_id(self) -> bool: ...

    def is_email(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def dropbox_id(cls, val: Text) -> MemberSelector: ...

    @classmethod
    def email(cls, val: Text) -> MemberSelector: ...

    def get_dropbox_id(self) -> Text: ...

    def get_email(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MemberSelector_validator: bv.Validator = ...

class ModifySharedLinkSettingsArgs(bb.Struct):
    def __init__(self,
                 url: Text = ...,
                 settings: SharedLinkSettings = ...,
                 remove_expiration: Optional[bool] = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    settings: bb.Attribute[SharedLinkSettings] = ...
    remove_expiration: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ModifySharedLinkSettingsArgs_validator: bv.Validator = ...

class ModifySharedLinkSettingsError(SharedLinkError):
    email_not_verified: ModifySharedLinkSettingsError = ...

    def is_settings_error(self) -> bool: ...

    def is_email_not_verified(self) -> bool: ...

    @classmethod
    def settings_error(cls, val: SharedLinkSettingsError) -> ModifySharedLinkSettingsError: ...

    def get_settings_error(self) -> SharedLinkSettingsError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ModifySharedLinkSettingsError_validator: bv.Validator = ...

class MountFolderArg(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MountFolderArg_validator: bv.Validator = ...

class MountFolderError(bb.Union):
    inside_shared_folder: MountFolderError = ...
    already_mounted: MountFolderError = ...
    no_permission: MountFolderError = ...
    not_mountable: MountFolderError = ...
    other: MountFolderError = ...

    def is_access_error(self) -> bool: ...

    def is_inside_shared_folder(self) -> bool: ...

    def is_insufficient_quota(self) -> bool: ...

    def is_already_mounted(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_not_mountable(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharedFolderAccessError) -> MountFolderError: ...

    @classmethod
    def insufficient_quota(cls, val: InsufficientQuotaAmounts) -> MountFolderError: ...

    def get_access_error(self) -> SharedFolderAccessError: ...

    def get_insufficient_quota(self) -> InsufficientQuotaAmounts: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MountFolderError_validator: bv.Validator = ...

class ParentFolderAccessInfo(bb.Struct):
    def __init__(self,
                 folder_name: Text = ...,
                 shared_folder_id: Text = ...,
                 permissions: List[MemberPermission] = ...,
                 path: Text = ...) -> None: ...
    folder_name: bb.Attribute[Text] = ...
    shared_folder_id: bb.Attribute[Text] = ...
    permissions: bb.Attribute[List[MemberPermission]] = ...
    path: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ParentFolderAccessInfo_validator: bv.Validator = ...

class PathLinkMetadata(LinkMetadata):
    def __init__(self,
                 url: Text = ...,
                 visibility: Visibility = ...,
                 path: Text = ...,
                 expires: Optional[datetime.datetime] = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    visibility: bb.Attribute[Visibility] = ...
    path: bb.Attribute[Text] = ...
    expires: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PathLinkMetadata_validator: bv.Validator = ...

class PendingUploadMode(bb.Union):
    file: PendingUploadMode = ...
    folder: PendingUploadMode = ...

    def is_file(self) -> bool: ...

    def is_folder(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PendingUploadMode_validator: bv.Validator = ...

class PermissionDeniedReason(bb.Union):
    user_not_same_team_as_owner: PermissionDeniedReason = ...
    user_not_allowed_by_owner: PermissionDeniedReason = ...
    target_is_indirect_member: PermissionDeniedReason = ...
    target_is_owner: PermissionDeniedReason = ...
    target_is_self: PermissionDeniedReason = ...
    target_not_active: PermissionDeniedReason = ...
    folder_is_limited_team_folder: PermissionDeniedReason = ...
    owner_not_on_team: PermissionDeniedReason = ...
    permission_denied: PermissionDeniedReason = ...
    restricted_by_team: PermissionDeniedReason = ...
    user_account_type: PermissionDeniedReason = ...
    user_not_on_team: PermissionDeniedReason = ...
    folder_is_inside_shared_folder: PermissionDeniedReason = ...
    restricted_by_parent_folder: PermissionDeniedReason = ...
    other: PermissionDeniedReason = ...

    def is_user_not_same_team_as_owner(self) -> bool: ...

    def is_user_not_allowed_by_owner(self) -> bool: ...

    def is_target_is_indirect_member(self) -> bool: ...

    def is_target_is_owner(self) -> bool: ...

    def is_target_is_self(self) -> bool: ...

    def is_target_not_active(self) -> bool: ...

    def is_folder_is_limited_team_folder(self) -> bool: ...

    def is_owner_not_on_team(self) -> bool: ...

    def is_permission_denied(self) -> bool: ...

    def is_restricted_by_team(self) -> bool: ...

    def is_user_account_type(self) -> bool: ...

    def is_user_not_on_team(self) -> bool: ...

    def is_folder_is_inside_shared_folder(self) -> bool: ...

    def is_restricted_by_parent_folder(self) -> bool: ...

    def is_insufficient_plan(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def insufficient_plan(cls, val: InsufficientPlan) -> PermissionDeniedReason: ...

    def get_insufficient_plan(self) -> InsufficientPlan: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PermissionDeniedReason_validator: bv.Validator = ...

class RelinquishFileMembershipArg(bb.Struct):
    def __init__(self,
                 file: Text = ...) -> None: ...
    file: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelinquishFileMembershipArg_validator: bv.Validator = ...

class RelinquishFileMembershipError(bb.Union):
    group_access: RelinquishFileMembershipError = ...
    no_permission: RelinquishFileMembershipError = ...
    other: RelinquishFileMembershipError = ...

    def is_access_error(self) -> bool: ...

    def is_group_access(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharingFileAccessError) -> RelinquishFileMembershipError: ...

    def get_access_error(self) -> SharingFileAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelinquishFileMembershipError_validator: bv.Validator = ...

class RelinquishFolderMembershipArg(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...,
                 leave_a_copy: Optional[bool] = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    leave_a_copy: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelinquishFolderMembershipArg_validator: bv.Validator = ...

class RelinquishFolderMembershipError(bb.Union):
    folder_owner: RelinquishFolderMembershipError = ...
    mounted: RelinquishFolderMembershipError = ...
    group_access: RelinquishFolderMembershipError = ...
    team_folder: RelinquishFolderMembershipError = ...
    no_permission: RelinquishFolderMembershipError = ...
    no_explicit_access: RelinquishFolderMembershipError = ...
    other: RelinquishFolderMembershipError = ...

    def is_access_error(self) -> bool: ...

    def is_folder_owner(self) -> bool: ...

    def is_mounted(self) -> bool: ...

    def is_group_access(self) -> bool: ...

    def is_team_folder(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_no_explicit_access(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharedFolderAccessError) -> RelinquishFolderMembershipError: ...

    def get_access_error(self) -> SharedFolderAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelinquishFolderMembershipError_validator: bv.Validator = ...

class RemoveFileMemberArg(bb.Struct):
    def __init__(self,
                 file: Text = ...,
                 member: MemberSelector = ...) -> None: ...
    file: bb.Attribute[Text] = ...
    member: bb.Attribute[MemberSelector] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RemoveFileMemberArg_validator: bv.Validator = ...

class RemoveFileMemberError(bb.Union):
    other: RemoveFileMemberError = ...

    def is_user_error(self) -> bool: ...

    def is_access_error(self) -> bool: ...

    def is_no_explicit_access(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def user_error(cls, val: SharingUserError) -> RemoveFileMemberError: ...

    @classmethod
    def access_error(cls, val: SharingFileAccessError) -> RemoveFileMemberError: ...

    @classmethod
    def no_explicit_access(cls, val: MemberAccessLevelResult) -> RemoveFileMemberError: ...

    def get_user_error(self) -> SharingUserError: ...

    def get_access_error(self) -> SharingFileAccessError: ...

    def get_no_explicit_access(self) -> MemberAccessLevelResult: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RemoveFileMemberError_validator: bv.Validator = ...

class RemoveFolderMemberArg(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...,
                 member: MemberSelector = ...,
                 leave_a_copy: bool = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    member: bb.Attribute[MemberSelector] = ...
    leave_a_copy: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RemoveFolderMemberArg_validator: bv.Validator = ...

class RemoveFolderMemberError(bb.Union):
    folder_owner: RemoveFolderMemberError = ...
    group_access: RemoveFolderMemberError = ...
    team_folder: RemoveFolderMemberError = ...
    no_permission: RemoveFolderMemberError = ...
    too_many_files: RemoveFolderMemberError = ...
    other: RemoveFolderMemberError = ...

    def is_access_error(self) -> bool: ...

    def is_member_error(self) -> bool: ...

    def is_folder_owner(self) -> bool: ...

    def is_group_access(self) -> bool: ...

    def is_team_folder(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_too_many_files(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharedFolderAccessError) -> RemoveFolderMemberError: ...

    @classmethod
    def member_error(cls, val: SharedFolderMemberError) -> RemoveFolderMemberError: ...

    def get_access_error(self) -> SharedFolderAccessError: ...

    def get_member_error(self) -> SharedFolderMemberError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RemoveFolderMemberError_validator: bv.Validator = ...

class RemoveMemberJobStatus(async_.PollResultBase):
    def is_complete(self) -> bool: ...

    def is_failed(self) -> bool: ...

    @classmethod
    def complete(cls, val: MemberAccessLevelResult) -> RemoveMemberJobStatus: ...

    @classmethod
    def failed(cls, val: RemoveFolderMemberError) -> RemoveMemberJobStatus: ...

    def get_complete(self) -> MemberAccessLevelResult: ...

    def get_failed(self) -> RemoveFolderMemberError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RemoveMemberJobStatus_validator: bv.Validator = ...

class RequestedLinkAccessLevel(bb.Union):
    viewer: RequestedLinkAccessLevel = ...
    editor: RequestedLinkAccessLevel = ...
    max: RequestedLinkAccessLevel = ...
    other: RequestedLinkAccessLevel = ...

    def is_viewer(self) -> bool: ...

    def is_editor(self) -> bool: ...

    def is_max(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RequestedLinkAccessLevel_validator: bv.Validator = ...

class RevokeSharedLinkArg(bb.Struct):
    def __init__(self,
                 url: Text = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeSharedLinkArg_validator: bv.Validator = ...

class RevokeSharedLinkError(SharedLinkError):
    shared_link_malformed: RevokeSharedLinkError = ...

    def is_shared_link_malformed(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RevokeSharedLinkError_validator: bv.Validator = ...

class SetAccessInheritanceArg(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...,
                 access_inheritance: Optional[AccessInheritance] = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    access_inheritance: bb.Attribute[AccessInheritance] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SetAccessInheritanceArg_validator: bv.Validator = ...

class SetAccessInheritanceError(bb.Union):
    no_permission: SetAccessInheritanceError = ...
    other: SetAccessInheritanceError = ...

    def is_access_error(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharedFolderAccessError) -> SetAccessInheritanceError: ...

    def get_access_error(self) -> SharedFolderAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SetAccessInheritanceError_validator: bv.Validator = ...

class ShareFolderArgBase(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 acl_update_policy: Optional[AclUpdatePolicy] = ...,
                 force_async: Optional[bool] = ...,
                 member_policy: Optional[MemberPolicy] = ...,
                 shared_link_policy: Optional[SharedLinkPolicy] = ...,
                 viewer_info_policy: Optional[ViewerInfoPolicy] = ...,
                 access_inheritance: Optional[AccessInheritance] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    acl_update_policy: bb.Attribute[Optional[AclUpdatePolicy]] = ...
    force_async: bb.Attribute[bool] = ...
    member_policy: bb.Attribute[Optional[MemberPolicy]] = ...
    shared_link_policy: bb.Attribute[Optional[SharedLinkPolicy]] = ...
    viewer_info_policy: bb.Attribute[Optional[ViewerInfoPolicy]] = ...
    access_inheritance: bb.Attribute[AccessInheritance] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ShareFolderArgBase_validator: bv.Validator = ...

class ShareFolderArg(ShareFolderArgBase):
    def __init__(self,
                 path: Text = ...,
                 acl_update_policy: Optional[AclUpdatePolicy] = ...,
                 force_async: Optional[bool] = ...,
                 member_policy: Optional[MemberPolicy] = ...,
                 shared_link_policy: Optional[SharedLinkPolicy] = ...,
                 viewer_info_policy: Optional[ViewerInfoPolicy] = ...,
                 access_inheritance: Optional[AccessInheritance] = ...,
                 actions: Optional[List[FolderAction]] = ...,
                 link_settings: Optional[LinkSettings] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    acl_update_policy: bb.Attribute[Optional[AclUpdatePolicy]] = ...
    force_async: bb.Attribute[bool] = ...
    member_policy: bb.Attribute[Optional[MemberPolicy]] = ...
    shared_link_policy: bb.Attribute[Optional[SharedLinkPolicy]] = ...
    viewer_info_policy: bb.Attribute[Optional[ViewerInfoPolicy]] = ...
    access_inheritance: bb.Attribute[AccessInheritance] = ...
    actions: bb.Attribute[Optional[List[FolderAction]]] = ...
    link_settings: bb.Attribute[Optional[LinkSettings]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ShareFolderArg_validator: bv.Validator = ...

class ShareFolderErrorBase(bb.Union):
    email_unverified: ShareFolderErrorBase = ...
    team_policy_disallows_member_policy: ShareFolderErrorBase = ...
    disallowed_shared_link_policy: ShareFolderErrorBase = ...
    other: ShareFolderErrorBase = ...

    def is_email_unverified(self) -> bool: ...

    def is_bad_path(self) -> bool: ...

    def is_team_policy_disallows_member_policy(self) -> bool: ...

    def is_disallowed_shared_link_policy(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def bad_path(cls, val: SharePathError) -> ShareFolderErrorBase: ...

    def get_bad_path(self) -> SharePathError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ShareFolderErrorBase_validator: bv.Validator = ...

class ShareFolderError(ShareFolderErrorBase):
    no_permission: ShareFolderError = ...

    def is_no_permission(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ShareFolderError_validator: bv.Validator = ...

class ShareFolderJobStatus(async_.PollResultBase):
    def is_complete(self) -> bool: ...

    def is_failed(self) -> bool: ...

    @classmethod
    def complete(cls, val: SharedFolderMetadata) -> ShareFolderJobStatus: ...

    @classmethod
    def failed(cls, val: ShareFolderError) -> ShareFolderJobStatus: ...

    def get_complete(self) -> SharedFolderMetadata: ...

    def get_failed(self) -> ShareFolderError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ShareFolderJobStatus_validator: bv.Validator = ...

class ShareFolderLaunch(async_.LaunchResultBase):
    def is_complete(self) -> bool: ...

    @classmethod
    def complete(cls, val: SharedFolderMetadata) -> ShareFolderLaunch: ...

    def get_complete(self) -> SharedFolderMetadata: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ShareFolderLaunch_validator: bv.Validator = ...

class SharePathError(bb.Union):
    is_file: SharePathError = ...
    inside_shared_folder: SharePathError = ...
    contains_shared_folder: SharePathError = ...
    contains_app_folder: SharePathError = ...
    contains_team_folder: SharePathError = ...
    is_app_folder: SharePathError = ...
    inside_app_folder: SharePathError = ...
    is_public_folder: SharePathError = ...
    inside_public_folder: SharePathError = ...
    invalid_path: SharePathError = ...
    is_osx_package: SharePathError = ...
    inside_osx_package: SharePathError = ...
    is_vault: SharePathError = ...
    is_vault_locked: SharePathError = ...
    is_family: SharePathError = ...
    other: SharePathError = ...

    def is_is_file(self) -> bool: ...

    def is_inside_shared_folder(self) -> bool: ...

    def is_contains_shared_folder(self) -> bool: ...

    def is_contains_app_folder(self) -> bool: ...

    def is_contains_team_folder(self) -> bool: ...

    def is_is_app_folder(self) -> bool: ...

    def is_inside_app_folder(self) -> bool: ...

    def is_is_public_folder(self) -> bool: ...

    def is_inside_public_folder(self) -> bool: ...

    def is_already_shared(self) -> bool: ...

    def is_invalid_path(self) -> bool: ...

    def is_is_osx_package(self) -> bool: ...

    def is_inside_osx_package(self) -> bool: ...

    def is_is_vault(self) -> bool: ...

    def is_is_vault_locked(self) -> bool: ...

    def is_is_family(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def already_shared(cls, val: SharedFolderMetadata) -> SharePathError: ...

    def get_already_shared(self) -> SharedFolderMetadata: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharePathError_validator: bv.Validator = ...

class SharedContentLinkMetadata(SharedContentLinkMetadataBase):
    def __init__(self,
                 audience_options: List[LinkAudience] = ...,
                 current_audience: LinkAudience = ...,
                 link_permissions: List[LinkPermission] = ...,
                 password_protected: bool = ...,
                 url: Text = ...,
                 access_level: Optional[AccessLevel] = ...,
                 audience_restricting_shared_folder: Optional[AudienceRestrictingSharedFolder] = ...,
                 expiry: Optional[datetime.datetime] = ...,
                 audience_exceptions: Optional[AudienceExceptions] = ...) -> None: ...
    audience_options: bb.Attribute[List[LinkAudience]] = ...
    current_audience: bb.Attribute[LinkAudience] = ...
    link_permissions: bb.Attribute[List[LinkPermission]] = ...
    password_protected: bb.Attribute[bool] = ...
    url: bb.Attribute[Text] = ...
    access_level: bb.Attribute[Optional[AccessLevel]] = ...
    audience_restricting_shared_folder: bb.Attribute[Optional[AudienceRestrictingSharedFolder]] = ...
    expiry: bb.Attribute[Optional[datetime.datetime]] = ...
    audience_exceptions: bb.Attribute[Optional[AudienceExceptions]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedContentLinkMetadata_validator: bv.Validator = ...

class SharedFileMembers(bb.Struct):
    def __init__(self,
                 users: List[UserFileMembershipInfo] = ...,
                 groups: List[GroupMembershipInfo] = ...,
                 invitees: List[InviteeMembershipInfo] = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    users: bb.Attribute[List[UserFileMembershipInfo]] = ...
    groups: bb.Attribute[List[GroupMembershipInfo]] = ...
    invitees: bb.Attribute[List[InviteeMembershipInfo]] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedFileMembers_validator: bv.Validator = ...

class SharedFileMetadata(bb.Struct):
    def __init__(self,
                 id: Text = ...,
                 name: Text = ...,
                 policy: FolderPolicy = ...,
                 preview_url: Text = ...,
                 access_type: Optional[AccessLevel] = ...,
                 expected_link_metadata: Optional[ExpectedSharedContentLinkMetadata] = ...,
                 link_metadata: Optional[SharedContentLinkMetadata] = ...,
                 owner_display_names: Optional[List[Text]] = ...,
                 owner_team: Optional[users.Team] = ...,
                 parent_shared_folder_id: Optional[Text] = ...,
                 path_display: Optional[Text] = ...,
                 path_lower: Optional[Text] = ...,
                 permissions: Optional[List[FilePermission]] = ...,
                 time_invited: Optional[datetime.datetime] = ...) -> None: ...
    id: bb.Attribute[Text] = ...
    name: bb.Attribute[Text] = ...
    policy: bb.Attribute[FolderPolicy] = ...
    preview_url: bb.Attribute[Text] = ...
    access_type: bb.Attribute[Optional[AccessLevel]] = ...
    expected_link_metadata: bb.Attribute[Optional[ExpectedSharedContentLinkMetadata]] = ...
    link_metadata: bb.Attribute[Optional[SharedContentLinkMetadata]] = ...
    owner_display_names: bb.Attribute[Optional[List[Text]]] = ...
    owner_team: bb.Attribute[Optional[users.Team]] = ...
    parent_shared_folder_id: bb.Attribute[Optional[Text]] = ...
    path_display: bb.Attribute[Optional[Text]] = ...
    path_lower: bb.Attribute[Optional[Text]] = ...
    permissions: bb.Attribute[Optional[List[FilePermission]]] = ...
    time_invited: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedFileMetadata_validator: bv.Validator = ...

class SharedFolderAccessError(bb.Union):
    invalid_id: SharedFolderAccessError = ...
    not_a_member: SharedFolderAccessError = ...
    email_unverified: SharedFolderAccessError = ...
    unmounted: SharedFolderAccessError = ...
    other: SharedFolderAccessError = ...

    def is_invalid_id(self) -> bool: ...

    def is_not_a_member(self) -> bool: ...

    def is_email_unverified(self) -> bool: ...

    def is_unmounted(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedFolderAccessError_validator: bv.Validator = ...

class SharedFolderMemberError(bb.Union):
    invalid_dropbox_id: SharedFolderMemberError = ...
    not_a_member: SharedFolderMemberError = ...
    other: SharedFolderMemberError = ...

    def is_invalid_dropbox_id(self) -> bool: ...

    def is_not_a_member(self) -> bool: ...

    def is_no_explicit_access(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def no_explicit_access(cls, val: MemberAccessLevelResult) -> SharedFolderMemberError: ...

    def get_no_explicit_access(self) -> MemberAccessLevelResult: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedFolderMemberError_validator: bv.Validator = ...

class SharedFolderMembers(bb.Struct):
    def __init__(self,
                 users: List[UserMembershipInfo] = ...,
                 groups: List[GroupMembershipInfo] = ...,
                 invitees: List[InviteeMembershipInfo] = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    users: bb.Attribute[List[UserMembershipInfo]] = ...
    groups: bb.Attribute[List[GroupMembershipInfo]] = ...
    invitees: bb.Attribute[List[InviteeMembershipInfo]] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedFolderMembers_validator: bv.Validator = ...

class SharedFolderMetadataBase(bb.Struct):
    def __init__(self,
                 access_type: AccessLevel = ...,
                 is_inside_team_folder: bool = ...,
                 is_team_folder: bool = ...,
                 owner_display_names: Optional[List[Text]] = ...,
                 owner_team: Optional[users.Team] = ...,
                 parent_shared_folder_id: Optional[Text] = ...,
                 path_lower: Optional[Text] = ...,
                 parent_folder_name: Optional[Text] = ...) -> None: ...
    access_type: bb.Attribute[AccessLevel] = ...
    is_inside_team_folder: bb.Attribute[bool] = ...
    is_team_folder: bb.Attribute[bool] = ...
    owner_display_names: bb.Attribute[Optional[List[Text]]] = ...
    owner_team: bb.Attribute[Optional[users.Team]] = ...
    parent_shared_folder_id: bb.Attribute[Optional[Text]] = ...
    path_lower: bb.Attribute[Optional[Text]] = ...
    parent_folder_name: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedFolderMetadataBase_validator: bv.Validator = ...

class SharedFolderMetadata(SharedFolderMetadataBase):
    def __init__(self,
                 access_type: AccessLevel = ...,
                 is_inside_team_folder: bool = ...,
                 is_team_folder: bool = ...,
                 name: Text = ...,
                 policy: FolderPolicy = ...,
                 preview_url: Text = ...,
                 shared_folder_id: Text = ...,
                 time_invited: datetime.datetime = ...,
                 owner_display_names: Optional[List[Text]] = ...,
                 owner_team: Optional[users.Team] = ...,
                 parent_shared_folder_id: Optional[Text] = ...,
                 path_lower: Optional[Text] = ...,
                 parent_folder_name: Optional[Text] = ...,
                 link_metadata: Optional[SharedContentLinkMetadata] = ...,
                 permissions: Optional[List[FolderPermission]] = ...,
                 access_inheritance: Optional[AccessInheritance] = ...) -> None: ...
    access_type: bb.Attribute[AccessLevel] = ...
    is_inside_team_folder: bb.Attribute[bool] = ...
    is_team_folder: bb.Attribute[bool] = ...
    name: bb.Attribute[Text] = ...
    policy: bb.Attribute[FolderPolicy] = ...
    preview_url: bb.Attribute[Text] = ...
    shared_folder_id: bb.Attribute[Text] = ...
    time_invited: bb.Attribute[datetime.datetime] = ...
    owner_display_names: bb.Attribute[Optional[List[Text]]] = ...
    owner_team: bb.Attribute[Optional[users.Team]] = ...
    parent_shared_folder_id: bb.Attribute[Optional[Text]] = ...
    path_lower: bb.Attribute[Optional[Text]] = ...
    parent_folder_name: bb.Attribute[Optional[Text]] = ...
    link_metadata: bb.Attribute[Optional[SharedContentLinkMetadata]] = ...
    permissions: bb.Attribute[Optional[List[FolderPermission]]] = ...
    access_inheritance: bb.Attribute[AccessInheritance] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedFolderMetadata_validator: bv.Validator = ...

class SharedLinkAccessFailureReason(bb.Union):
    login_required: SharedLinkAccessFailureReason = ...
    email_verify_required: SharedLinkAccessFailureReason = ...
    password_required: SharedLinkAccessFailureReason = ...
    team_only: SharedLinkAccessFailureReason = ...
    owner_only: SharedLinkAccessFailureReason = ...
    other: SharedLinkAccessFailureReason = ...

    def is_login_required(self) -> bool: ...

    def is_email_verify_required(self) -> bool: ...

    def is_password_required(self) -> bool: ...

    def is_team_only(self) -> bool: ...

    def is_owner_only(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedLinkAccessFailureReason_validator: bv.Validator = ...

class SharedLinkAlreadyExistsMetadata(bb.Union):
    other: SharedLinkAlreadyExistsMetadata = ...

    def is_metadata(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def metadata(cls, val: SharedLinkMetadata) -> SharedLinkAlreadyExistsMetadata: ...

    def get_metadata(self) -> SharedLinkMetadata: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedLinkAlreadyExistsMetadata_validator: bv.Validator = ...

class SharedLinkPolicy(bb.Union):
    anyone: SharedLinkPolicy = ...
    team: SharedLinkPolicy = ...
    members: SharedLinkPolicy = ...
    other: SharedLinkPolicy = ...

    def is_anyone(self) -> bool: ...

    def is_team(self) -> bool: ...

    def is_members(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedLinkPolicy_validator: bv.Validator = ...

class SharedLinkSettings(bb.Struct):
    def __init__(self,
                 require_password: Optional[bool] = ...,
                 link_password: Optional[Text] = ...,
                 expires: Optional[datetime.datetime] = ...,
                 audience: Optional[LinkAudience] = ...,
                 access: Optional[RequestedLinkAccessLevel] = ...,
                 requested_visibility: Optional[RequestedVisibility] = ...,
                 allow_download: Optional[bool] = ...) -> None: ...
    require_password: bb.Attribute[Optional[bool]] = ...
    link_password: bb.Attribute[Optional[Text]] = ...
    expires: bb.Attribute[Optional[datetime.datetime]] = ...
    audience: bb.Attribute[Optional[LinkAudience]] = ...
    access: bb.Attribute[Optional[RequestedLinkAccessLevel]] = ...
    requested_visibility: bb.Attribute[Optional[RequestedVisibility]] = ...
    allow_download: bb.Attribute[Optional[bool]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedLinkSettings_validator: bv.Validator = ...

class SharedLinkSettingsError(bb.Union):
    invalid_settings: SharedLinkSettingsError = ...
    not_authorized: SharedLinkSettingsError = ...

    def is_invalid_settings(self) -> bool: ...

    def is_not_authorized(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedLinkSettingsError_validator: bv.Validator = ...

class SharingFileAccessError(bb.Union):
    no_permission: SharingFileAccessError = ...
    invalid_file: SharingFileAccessError = ...
    is_folder: SharingFileAccessError = ...
    inside_public_folder: SharingFileAccessError = ...
    inside_osx_package: SharingFileAccessError = ...
    other: SharingFileAccessError = ...

    def is_no_permission(self) -> bool: ...

    def is_invalid_file(self) -> bool: ...

    def is_is_folder(self) -> bool: ...

    def is_inside_public_folder(self) -> bool: ...

    def is_inside_osx_package(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharingFileAccessError_validator: bv.Validator = ...

class SharingUserError(bb.Union):
    email_unverified: SharingUserError = ...
    other: SharingUserError = ...

    def is_email_unverified(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharingUserError_validator: bv.Validator = ...

class TeamMemberInfo(bb.Struct):
    def __init__(self,
                 team_info: users.Team = ...,
                 display_name: Text = ...,
                 member_id: Optional[Text] = ...) -> None: ...
    team_info: bb.Attribute[users.Team] = ...
    display_name: bb.Attribute[Text] = ...
    member_id: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamMemberInfo_validator: bv.Validator = ...

class TransferFolderArg(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...,
                 to_dropbox_id: Text = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    to_dropbox_id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TransferFolderArg_validator: bv.Validator = ...

class TransferFolderError(bb.Union):
    invalid_dropbox_id: TransferFolderError = ...
    new_owner_not_a_member: TransferFolderError = ...
    new_owner_unmounted: TransferFolderError = ...
    new_owner_email_unverified: TransferFolderError = ...
    team_folder: TransferFolderError = ...
    no_permission: TransferFolderError = ...
    other: TransferFolderError = ...

    def is_access_error(self) -> bool: ...

    def is_invalid_dropbox_id(self) -> bool: ...

    def is_new_owner_not_a_member(self) -> bool: ...

    def is_new_owner_unmounted(self) -> bool: ...

    def is_new_owner_email_unverified(self) -> bool: ...

    def is_team_folder(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharedFolderAccessError) -> TransferFolderError: ...

    def get_access_error(self) -> SharedFolderAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TransferFolderError_validator: bv.Validator = ...

class UnmountFolderArg(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UnmountFolderArg_validator: bv.Validator = ...

class UnmountFolderError(bb.Union):
    no_permission: UnmountFolderError = ...
    not_unmountable: UnmountFolderError = ...
    other: UnmountFolderError = ...

    def is_access_error(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_not_unmountable(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharedFolderAccessError) -> UnmountFolderError: ...

    def get_access_error(self) -> SharedFolderAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UnmountFolderError_validator: bv.Validator = ...

class UnshareFileArg(bb.Struct):
    def __init__(self,
                 file: Text = ...) -> None: ...
    file: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UnshareFileArg_validator: bv.Validator = ...

class UnshareFileError(bb.Union):
    other: UnshareFileError = ...

    def is_user_error(self) -> bool: ...

    def is_access_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def user_error(cls, val: SharingUserError) -> UnshareFileError: ...

    @classmethod
    def access_error(cls, val: SharingFileAccessError) -> UnshareFileError: ...

    def get_user_error(self) -> SharingUserError: ...

    def get_access_error(self) -> SharingFileAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UnshareFileError_validator: bv.Validator = ...

class UnshareFolderArg(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...,
                 leave_a_copy: Optional[bool] = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    leave_a_copy: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UnshareFolderArg_validator: bv.Validator = ...

class UnshareFolderError(bb.Union):
    team_folder: UnshareFolderError = ...
    no_permission: UnshareFolderError = ...
    too_many_files: UnshareFolderError = ...
    other: UnshareFolderError = ...

    def is_access_error(self) -> bool: ...

    def is_team_folder(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_too_many_files(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharedFolderAccessError) -> UnshareFolderError: ...

    def get_access_error(self) -> SharedFolderAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UnshareFolderError_validator: bv.Validator = ...

class UpdateFileMemberArgs(bb.Struct):
    def __init__(self,
                 file: Text = ...,
                 member: MemberSelector = ...,
                 access_level: AccessLevel = ...) -> None: ...
    file: bb.Attribute[Text] = ...
    member: bb.Attribute[MemberSelector] = ...
    access_level: bb.Attribute[AccessLevel] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UpdateFileMemberArgs_validator: bv.Validator = ...

class UpdateFolderMemberArg(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...,
                 member: MemberSelector = ...,
                 access_level: AccessLevel = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    member: bb.Attribute[MemberSelector] = ...
    access_level: bb.Attribute[AccessLevel] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UpdateFolderMemberArg_validator: bv.Validator = ...

class UpdateFolderMemberError(bb.Union):
    insufficient_plan: UpdateFolderMemberError = ...
    no_permission: UpdateFolderMemberError = ...
    other: UpdateFolderMemberError = ...

    def is_access_error(self) -> bool: ...

    def is_member_error(self) -> bool: ...

    def is_no_explicit_access(self) -> bool: ...

    def is_insufficient_plan(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharedFolderAccessError) -> UpdateFolderMemberError: ...

    @classmethod
    def member_error(cls, val: SharedFolderMemberError) -> UpdateFolderMemberError: ...

    @classmethod
    def no_explicit_access(cls, val: AddFolderMemberError) -> UpdateFolderMemberError: ...

    def get_access_error(self) -> SharedFolderAccessError: ...

    def get_member_error(self) -> SharedFolderMemberError: ...

    def get_no_explicit_access(self) -> AddFolderMemberError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UpdateFolderMemberError_validator: bv.Validator = ...

class UpdateFolderPolicyArg(bb.Struct):
    def __init__(self,
                 shared_folder_id: Text = ...,
                 member_policy: Optional[MemberPolicy] = ...,
                 acl_update_policy: Optional[AclUpdatePolicy] = ...,
                 viewer_info_policy: Optional[ViewerInfoPolicy] = ...,
                 shared_link_policy: Optional[SharedLinkPolicy] = ...,
                 link_settings: Optional[LinkSettings] = ...,
                 actions: Optional[List[FolderAction]] = ...) -> None: ...
    shared_folder_id: bb.Attribute[Text] = ...
    member_policy: bb.Attribute[Optional[MemberPolicy]] = ...
    acl_update_policy: bb.Attribute[Optional[AclUpdatePolicy]] = ...
    viewer_info_policy: bb.Attribute[Optional[ViewerInfoPolicy]] = ...
    shared_link_policy: bb.Attribute[Optional[SharedLinkPolicy]] = ...
    link_settings: bb.Attribute[Optional[LinkSettings]] = ...
    actions: bb.Attribute[Optional[List[FolderAction]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UpdateFolderPolicyArg_validator: bv.Validator = ...

class UpdateFolderPolicyError(bb.Union):
    not_on_team: UpdateFolderPolicyError = ...
    team_policy_disallows_member_policy: UpdateFolderPolicyError = ...
    disallowed_shared_link_policy: UpdateFolderPolicyError = ...
    no_permission: UpdateFolderPolicyError = ...
    team_folder: UpdateFolderPolicyError = ...
    other: UpdateFolderPolicyError = ...

    def is_access_error(self) -> bool: ...

    def is_not_on_team(self) -> bool: ...

    def is_team_policy_disallows_member_policy(self) -> bool: ...

    def is_disallowed_shared_link_policy(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_team_folder(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def access_error(cls, val: SharedFolderAccessError) -> UpdateFolderPolicyError: ...

    def get_access_error(self) -> SharedFolderAccessError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UpdateFolderPolicyError_validator: bv.Validator = ...

class UserMembershipInfo(MembershipInfo):
    def __init__(self,
                 access_type: AccessLevel = ...,
                 user: UserInfo = ...,
                 permissions: Optional[List[MemberPermission]] = ...,
                 initials: Optional[Text] = ...,
                 is_inherited: Optional[bool] = ...) -> None: ...
    access_type: bb.Attribute[AccessLevel] = ...
    user: bb.Attribute[UserInfo] = ...
    permissions: bb.Attribute[Optional[List[MemberPermission]]] = ...
    initials: bb.Attribute[Optional[Text]] = ...
    is_inherited: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserMembershipInfo_validator: bv.Validator = ...

class UserFileMembershipInfo(UserMembershipInfo):
    def __init__(self,
                 access_type: AccessLevel = ...,
                 user: UserInfo = ...,
                 permissions: Optional[List[MemberPermission]] = ...,
                 initials: Optional[Text] = ...,
                 is_inherited: Optional[bool] = ...,
                 time_last_seen: Optional[datetime.datetime] = ...,
                 platform_type: Optional[seen_state.PlatformType] = ...) -> None: ...
    access_type: bb.Attribute[AccessLevel] = ...
    user: bb.Attribute[UserInfo] = ...
    permissions: bb.Attribute[Optional[List[MemberPermission]]] = ...
    initials: bb.Attribute[Optional[Text]] = ...
    is_inherited: bb.Attribute[bool] = ...
    time_last_seen: bb.Attribute[Optional[datetime.datetime]] = ...
    platform_type: bb.Attribute[Optional[seen_state.PlatformType]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserFileMembershipInfo_validator: bv.Validator = ...

class UserInfo(bb.Struct):
    def __init__(self,
                 account_id: Text = ...,
                 email: Text = ...,
                 display_name: Text = ...,
                 same_team: bool = ...,
                 team_member_id: Optional[Text] = ...) -> None: ...
    account_id: bb.Attribute[Text] = ...
    email: bb.Attribute[Text] = ...
    display_name: bb.Attribute[Text] = ...
    same_team: bb.Attribute[bool] = ...
    team_member_id: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserInfo_validator: bv.Validator = ...

class ViewerInfoPolicy(bb.Union):
    enabled: ViewerInfoPolicy = ...
    disabled: ViewerInfoPolicy = ...
    other: ViewerInfoPolicy = ...

    def is_enabled(self) -> bool: ...

    def is_disabled(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ViewerInfoPolicy_validator: bv.Validator = ...

class Visibility(bb.Union):
    public: Visibility = ...
    team_only: Visibility = ...
    password: Visibility = ...
    team_and_password: Visibility = ...
    shared_folder_only: Visibility = ...
    other: Visibility = ...

    def is_public(self) -> bool: ...

    def is_team_only(self) -> bool: ...

    def is_password(self) -> bool: ...

    def is_team_and_password(self) -> bool: ...

    def is_shared_folder_only(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

Visibility_validator: bv.Validator = ...

class VisibilityPolicy(bb.Struct):
    def __init__(self,
                 policy: RequestedVisibility = ...,
                 resolved_policy: AlphaResolvedVisibility = ...,
                 allowed: bool = ...,
                 disallowed_reason: Optional[VisibilityPolicyDisallowedReason] = ...) -> None: ...
    policy: bb.Attribute[RequestedVisibility] = ...
    resolved_policy: bb.Attribute[AlphaResolvedVisibility] = ...
    allowed: bb.Attribute[bool] = ...
    disallowed_reason: bb.Attribute[Optional[VisibilityPolicyDisallowedReason]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

VisibilityPolicy_validator: bv.Validator = ...

DropboxId_validator: bv.Validator = ...
GetSharedLinkFileArg_validator: bv.Validator = ...
GetSharedLinkFileArg = GetSharedLinkMetadataArg
Id_validator: bv.Validator = ...
Path_validator: bv.Validator = ...
PathOrId_validator: bv.Validator = ...
ReadPath_validator: bv.Validator = ...
Rev_validator: bv.Validator = ...
TeamInfo_validator: bv.Validator = ...
TeamInfo = users.Team
add_file_member: bb.Route = ...
add_folder_member: bb.Route = ...
check_job_status: bb.Route = ...
check_remove_member_job_status: bb.Route = ...
check_share_job_status: bb.Route = ...
create_shared_link: bb.Route = ...
create_shared_link_with_settings: bb.Route = ...
get_file_metadata: bb.Route = ...
get_file_metadata_batch: bb.Route = ...
get_folder_metadata: bb.Route = ...
get_shared_link_file: bb.Route = ...
get_shared_link_metadata: bb.Route = ...
get_shared_links: bb.Route = ...
list_file_members: bb.Route = ...
list_file_members_batch: bb.Route = ...
list_file_members_continue: bb.Route = ...
list_folder_members: bb.Route = ...
list_folder_members_continue: bb.Route = ...
list_folders: bb.Route = ...
list_folders_continue: bb.Route = ...
list_mountable_folders: bb.Route = ...
list_mountable_folders_continue: bb.Route = ...
list_received_files: bb.Route = ...
list_received_files_continue: bb.Route = ...
list_shared_links: bb.Route = ...
modify_shared_link_settings: bb.Route = ...
mount_folder: bb.Route = ...
relinquish_file_membership: bb.Route = ...
relinquish_folder_membership: bb.Route = ...
remove_file_member: bb.Route = ...
remove_file_member_2: bb.Route = ...
remove_folder_member: bb.Route = ...
revoke_shared_link: bb.Route = ...
set_access_inheritance: bb.Route = ...
share_folder: bb.Route = ...
transfer_folder: bb.Route = ...
unmount_folder: bb.Route = ...
unshare_file: bb.Route = ...
unshare_folder: bb.Route = ...
update_file_member: bb.Route = ...
update_folder_member: bb.Route = ...
update_folder_policy: bb.Route = ...


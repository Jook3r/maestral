# -*- coding: utf-8 -*-
# Auto-generated by Stone, do not modify.
# @generated
# flake8: noqa
# pylint: skip-file

from typing import (
    Callable,
    List,
    Optional,
    Text,
    Type,
    TypeVar,
)

import datetime
from stone.backends.python_rsrc import stone_base as bb  # type: ignore
from stone.backends.python_rsrc import stone_validators as bv  # type: ignore

from dropbox import async_  # type: ignore
from dropbox import common  # type: ignore
from dropbox import file_properties  # type: ignore
from dropbox import users_common  # type: ignore

T = TypeVar('T', bound=bb.AnnotationType)
U = TypeVar('U')

class AddTagArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 tag_text: Text = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    tag_text: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddTagArg_validator: bv.Validator = ...

class BaseTagError(bb.Union):
    other: BaseTagError = ...

    def is_path(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> BaseTagError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

BaseTagError_validator: bv.Validator = ...

class AddTagError(BaseTagError):
    too_many_tags: AddTagError = ...

    def is_too_many_tags(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AddTagError_validator: bv.Validator = ...

class GetMetadataArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 include_media_info: Optional[bool] = ...,
                 include_deleted: Optional[bool] = ...,
                 include_has_explicit_shared_members: Optional[bool] = ...,
                 include_property_groups: Optional[file_properties.TemplateFilterBase] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    include_media_info: bb.Attribute[bool] = ...
    include_deleted: bb.Attribute[bool] = ...
    include_has_explicit_shared_members: bb.Attribute[bool] = ...
    include_property_groups: bb.Attribute[Optional[file_properties.TemplateFilterBase]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetMetadataArg_validator: bv.Validator = ...

class AlphaGetMetadataArg(GetMetadataArg):
    def __init__(self,
                 path: Text = ...,
                 include_media_info: Optional[bool] = ...,
                 include_deleted: Optional[bool] = ...,
                 include_has_explicit_shared_members: Optional[bool] = ...,
                 include_property_groups: Optional[file_properties.TemplateFilterBase] = ...,
                 include_property_templates: Optional[List[Text]] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    include_media_info: bb.Attribute[bool] = ...
    include_deleted: bb.Attribute[bool] = ...
    include_has_explicit_shared_members: bb.Attribute[bool] = ...
    include_property_groups: bb.Attribute[Optional[file_properties.TemplateFilterBase]] = ...
    include_property_templates: bb.Attribute[Optional[List[Text]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AlphaGetMetadataArg_validator: bv.Validator = ...

class GetMetadataError(bb.Union):
    def is_path(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> GetMetadataError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetMetadataError_validator: bv.Validator = ...

class AlphaGetMetadataError(GetMetadataError):
    def is_properties_error(self) -> bool: ...

    @classmethod
    def properties_error(cls, val: file_properties.LookUpPropertiesError) -> AlphaGetMetadataError: ...

    def get_properties_error(self) -> file_properties.LookUpPropertiesError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

AlphaGetMetadataError_validator: bv.Validator = ...

class CommitInfo(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 mode: Optional[WriteMode] = ...,
                 autorename: Optional[bool] = ...,
                 client_modified: Optional[datetime.datetime] = ...,
                 mute: Optional[bool] = ...,
                 property_groups: Optional[List[file_properties.PropertyGroup]] = ...,
                 strict_conflict: Optional[bool] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    mode: bb.Attribute[WriteMode] = ...
    autorename: bb.Attribute[bool] = ...
    client_modified: bb.Attribute[Optional[datetime.datetime]] = ...
    mute: bb.Attribute[bool] = ...
    property_groups: bb.Attribute[Optional[List[file_properties.PropertyGroup]]] = ...
    strict_conflict: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CommitInfo_validator: bv.Validator = ...

class ContentSyncSetting(bb.Struct):
    def __init__(self,
                 id: Text = ...,
                 sync_setting: SyncSetting = ...) -> None: ...
    id: bb.Attribute[Text] = ...
    sync_setting: bb.Attribute[SyncSetting] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ContentSyncSetting_validator: bv.Validator = ...

class ContentSyncSettingArg(bb.Struct):
    def __init__(self,
                 id: Text = ...,
                 sync_setting: SyncSettingArg = ...) -> None: ...
    id: bb.Attribute[Text] = ...
    sync_setting: bb.Attribute[SyncSettingArg] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ContentSyncSettingArg_validator: bv.Validator = ...

class CreateFolderArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 autorename: Optional[bool] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    autorename: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateFolderArg_validator: bv.Validator = ...

class CreateFolderBatchArg(bb.Struct):
    def __init__(self,
                 paths: List[Text] = ...,
                 autorename: Optional[bool] = ...,
                 force_async: Optional[bool] = ...) -> None: ...
    paths: bb.Attribute[List[Text]] = ...
    autorename: bb.Attribute[bool] = ...
    force_async: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateFolderBatchArg_validator: bv.Validator = ...

class CreateFolderBatchError(bb.Union):
    too_many_files: CreateFolderBatchError = ...
    other: CreateFolderBatchError = ...

    def is_too_many_files(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateFolderBatchError_validator: bv.Validator = ...

class CreateFolderBatchJobStatus(async_.PollResultBase):
    other: CreateFolderBatchJobStatus = ...

    def is_complete(self) -> bool: ...

    def is_failed(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def complete(cls, val: CreateFolderBatchResult) -> CreateFolderBatchJobStatus: ...

    @classmethod
    def failed(cls, val: CreateFolderBatchError) -> CreateFolderBatchJobStatus: ...

    def get_complete(self) -> CreateFolderBatchResult: ...

    def get_failed(self) -> CreateFolderBatchError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateFolderBatchJobStatus_validator: bv.Validator = ...

class CreateFolderBatchLaunch(async_.LaunchResultBase):
    other: CreateFolderBatchLaunch = ...

    def is_complete(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def complete(cls, val: CreateFolderBatchResult) -> CreateFolderBatchLaunch: ...

    def get_complete(self) -> CreateFolderBatchResult: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateFolderBatchLaunch_validator: bv.Validator = ...

class FileOpsResult(bb.Struct):
    def __init__(self) -> None: ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileOpsResult_validator: bv.Validator = ...

class CreateFolderBatchResult(FileOpsResult):
    def __init__(self,
                 entries: List[CreateFolderBatchResultEntry] = ...) -> None: ...
    entries: bb.Attribute[List[CreateFolderBatchResultEntry]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateFolderBatchResult_validator: bv.Validator = ...

class CreateFolderBatchResultEntry(bb.Union):
    def is_success(self) -> bool: ...

    def is_failure(self) -> bool: ...

    @classmethod
    def success(cls, val: CreateFolderEntryResult) -> CreateFolderBatchResultEntry: ...

    @classmethod
    def failure(cls, val: CreateFolderEntryError) -> CreateFolderBatchResultEntry: ...

    def get_success(self) -> CreateFolderEntryResult: ...

    def get_failure(self) -> CreateFolderEntryError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateFolderBatchResultEntry_validator: bv.Validator = ...

class CreateFolderEntryError(bb.Union):
    other: CreateFolderEntryError = ...

    def is_path(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: WriteError) -> CreateFolderEntryError: ...

    def get_path(self) -> WriteError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateFolderEntryError_validator: bv.Validator = ...

class CreateFolderEntryResult(bb.Struct):
    def __init__(self,
                 metadata: FolderMetadata = ...) -> None: ...
    metadata: bb.Attribute[FolderMetadata] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateFolderEntryResult_validator: bv.Validator = ...

class CreateFolderError(bb.Union):
    def is_path(self) -> bool: ...

    @classmethod
    def path(cls, val: WriteError) -> CreateFolderError: ...

    def get_path(self) -> WriteError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateFolderError_validator: bv.Validator = ...

class CreateFolderResult(FileOpsResult):
    def __init__(self,
                 metadata: FolderMetadata = ...) -> None: ...
    metadata: bb.Attribute[FolderMetadata] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

CreateFolderResult_validator: bv.Validator = ...

class DeleteArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 parent_rev: Optional[Text] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    parent_rev: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteArg_validator: bv.Validator = ...

class DeleteBatchArg(bb.Struct):
    def __init__(self,
                 entries: List[DeleteArg] = ...) -> None: ...
    entries: bb.Attribute[List[DeleteArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteBatchArg_validator: bv.Validator = ...

class DeleteBatchError(bb.Union):
    too_many_write_operations: DeleteBatchError = ...
    other: DeleteBatchError = ...

    def is_too_many_write_operations(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteBatchError_validator: bv.Validator = ...

class DeleteBatchJobStatus(async_.PollResultBase):
    other: DeleteBatchJobStatus = ...

    def is_complete(self) -> bool: ...

    def is_failed(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def complete(cls, val: DeleteBatchResult) -> DeleteBatchJobStatus: ...

    @classmethod
    def failed(cls, val: DeleteBatchError) -> DeleteBatchJobStatus: ...

    def get_complete(self) -> DeleteBatchResult: ...

    def get_failed(self) -> DeleteBatchError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteBatchJobStatus_validator: bv.Validator = ...

class DeleteBatchLaunch(async_.LaunchResultBase):
    other: DeleteBatchLaunch = ...

    def is_complete(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def complete(cls, val: DeleteBatchResult) -> DeleteBatchLaunch: ...

    def get_complete(self) -> DeleteBatchResult: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteBatchLaunch_validator: bv.Validator = ...

class DeleteBatchResult(FileOpsResult):
    def __init__(self,
                 entries: List[DeleteBatchResultEntry] = ...) -> None: ...
    entries: bb.Attribute[List[DeleteBatchResultEntry]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteBatchResult_validator: bv.Validator = ...

class DeleteBatchResultData(bb.Struct):
    def __init__(self,
                 metadata: Metadata = ...) -> None: ...
    metadata: bb.Attribute[Metadata] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteBatchResultData_validator: bv.Validator = ...

class DeleteBatchResultEntry(bb.Union):
    def is_success(self) -> bool: ...

    def is_failure(self) -> bool: ...

    @classmethod
    def success(cls, val: DeleteBatchResultData) -> DeleteBatchResultEntry: ...

    @classmethod
    def failure(cls, val: DeleteError) -> DeleteBatchResultEntry: ...

    def get_success(self) -> DeleteBatchResultData: ...

    def get_failure(self) -> DeleteError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteBatchResultEntry_validator: bv.Validator = ...

class DeleteError(bb.Union):
    too_many_write_operations: DeleteError = ...
    too_many_files: DeleteError = ...
    other: DeleteError = ...

    def is_path_lookup(self) -> bool: ...

    def is_path_write(self) -> bool: ...

    def is_too_many_write_operations(self) -> bool: ...

    def is_too_many_files(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path_lookup(cls, val: LookupError) -> DeleteError: ...

    @classmethod
    def path_write(cls, val: WriteError) -> DeleteError: ...

    def get_path_lookup(self) -> LookupError: ...

    def get_path_write(self) -> WriteError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteError_validator: bv.Validator = ...

class DeleteResult(FileOpsResult):
    def __init__(self,
                 metadata: Metadata = ...) -> None: ...
    metadata: bb.Attribute[Metadata] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeleteResult_validator: bv.Validator = ...

class Metadata(bb.Struct):
    def __init__(self,
                 name: Text = ...,
                 path_lower: Optional[Text] = ...,
                 path_display: Optional[Text] = ...,
                 parent_shared_folder_id: Optional[Text] = ...) -> None: ...
    name: bb.Attribute[Text] = ...
    path_lower: bb.Attribute[Optional[Text]] = ...
    path_display: bb.Attribute[Optional[Text]] = ...
    parent_shared_folder_id: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

Metadata_validator: bv.Validator = ...

class DeletedMetadata(Metadata):
    def __init__(self,
                 name: Text = ...,
                 path_lower: Optional[Text] = ...,
                 path_display: Optional[Text] = ...,
                 parent_shared_folder_id: Optional[Text] = ...) -> None: ...
    name: bb.Attribute[Text] = ...
    path_lower: bb.Attribute[Optional[Text]] = ...
    path_display: bb.Attribute[Optional[Text]] = ...
    parent_shared_folder_id: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DeletedMetadata_validator: bv.Validator = ...

class Dimensions(bb.Struct):
    def __init__(self,
                 height: int = ...,
                 width: int = ...) -> None: ...
    height: bb.Attribute[int] = ...
    width: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

Dimensions_validator: bv.Validator = ...

class DownloadArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 rev: Optional[Text] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    rev: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DownloadArg_validator: bv.Validator = ...

class DownloadError(bb.Union):
    unsupported_file: DownloadError = ...
    other: DownloadError = ...

    def is_path(self) -> bool: ...

    def is_unsupported_file(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> DownloadError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DownloadError_validator: bv.Validator = ...

class DownloadZipArg(bb.Struct):
    def __init__(self,
                 path: Text = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DownloadZipArg_validator: bv.Validator = ...

class DownloadZipError(bb.Union):
    too_large: DownloadZipError = ...
    too_many_files: DownloadZipError = ...
    other: DownloadZipError = ...

    def is_path(self) -> bool: ...

    def is_too_large(self) -> bool: ...

    def is_too_many_files(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> DownloadZipError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DownloadZipError_validator: bv.Validator = ...

class DownloadZipResult(bb.Struct):
    def __init__(self,
                 metadata: FolderMetadata = ...) -> None: ...
    metadata: bb.Attribute[FolderMetadata] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

DownloadZipResult_validator: bv.Validator = ...

class ExportArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 export_format: Optional[Text] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    export_format: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExportArg_validator: bv.Validator = ...

class ExportError(bb.Union):
    non_exportable: ExportError = ...
    invalid_export_format: ExportError = ...
    retry_error: ExportError = ...
    other: ExportError = ...

    def is_path(self) -> bool: ...

    def is_non_exportable(self) -> bool: ...

    def is_invalid_export_format(self) -> bool: ...

    def is_retry_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> ExportError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExportError_validator: bv.Validator = ...

class ExportInfo(bb.Struct):
    def __init__(self,
                 export_as: Optional[Text] = ...,
                 export_options: Optional[List[Text]] = ...) -> None: ...
    export_as: bb.Attribute[Optional[Text]] = ...
    export_options: bb.Attribute[Optional[List[Text]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExportInfo_validator: bv.Validator = ...

class ExportMetadata(bb.Struct):
    def __init__(self,
                 name: Text = ...,
                 size: int = ...,
                 export_hash: Optional[Text] = ...,
                 paper_revision: Optional[int] = ...) -> None: ...
    name: bb.Attribute[Text] = ...
    size: bb.Attribute[int] = ...
    export_hash: bb.Attribute[Optional[Text]] = ...
    paper_revision: bb.Attribute[Optional[int]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExportMetadata_validator: bv.Validator = ...

class ExportResult(bb.Struct):
    def __init__(self,
                 export_metadata: ExportMetadata = ...,
                 file_metadata: FileMetadata = ...) -> None: ...
    export_metadata: bb.Attribute[ExportMetadata] = ...
    file_metadata: bb.Attribute[FileMetadata] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ExportResult_validator: bv.Validator = ...

class FileCategory(bb.Union):
    image: FileCategory = ...
    document: FileCategory = ...
    pdf: FileCategory = ...
    spreadsheet: FileCategory = ...
    presentation: FileCategory = ...
    audio: FileCategory = ...
    video: FileCategory = ...
    folder: FileCategory = ...
    paper: FileCategory = ...
    others: FileCategory = ...
    other: FileCategory = ...

    def is_image(self) -> bool: ...

    def is_document(self) -> bool: ...

    def is_pdf(self) -> bool: ...

    def is_spreadsheet(self) -> bool: ...

    def is_presentation(self) -> bool: ...

    def is_audio(self) -> bool: ...

    def is_video(self) -> bool: ...

    def is_folder(self) -> bool: ...

    def is_paper(self) -> bool: ...

    def is_others(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileCategory_validator: bv.Validator = ...

class FileLock(bb.Struct):
    def __init__(self,
                 content: FileLockContent = ...) -> None: ...
    content: bb.Attribute[FileLockContent] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileLock_validator: bv.Validator = ...

class FileLockContent(bb.Union):
    unlocked: FileLockContent = ...
    other: FileLockContent = ...

    def is_unlocked(self) -> bool: ...

    def is_single_user(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def single_user(cls, val: SingleUserLock) -> FileLockContent: ...

    def get_single_user(self) -> SingleUserLock: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileLockContent_validator: bv.Validator = ...

class FileLockMetadata(bb.Struct):
    def __init__(self,
                 is_lockholder: Optional[bool] = ...,
                 lockholder_name: Optional[Text] = ...,
                 lockholder_account_id: Optional[Text] = ...,
                 created: Optional[datetime.datetime] = ...) -> None: ...
    is_lockholder: bb.Attribute[Optional[bool]] = ...
    lockholder_name: bb.Attribute[Optional[Text]] = ...
    lockholder_account_id: bb.Attribute[Optional[Text]] = ...
    created: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileLockMetadata_validator: bv.Validator = ...

class FileMetadata(Metadata):
    def __init__(self,
                 name: Text = ...,
                 id: Text = ...,
                 client_modified: datetime.datetime = ...,
                 server_modified: datetime.datetime = ...,
                 rev: Text = ...,
                 size: int = ...,
                 path_lower: Optional[Text] = ...,
                 path_display: Optional[Text] = ...,
                 parent_shared_folder_id: Optional[Text] = ...,
                 media_info: Optional[MediaInfo] = ...,
                 symlink_info: Optional[SymlinkInfo] = ...,
                 sharing_info: Optional[FileSharingInfo] = ...,
                 is_downloadable: Optional[bool] = ...,
                 export_info: Optional[ExportInfo] = ...,
                 property_groups: Optional[List[file_properties.PropertyGroup]] = ...,
                 has_explicit_shared_members: Optional[bool] = ...,
                 content_hash: Optional[Text] = ...,
                 file_lock_info: Optional[FileLockMetadata] = ...) -> None: ...
    name: bb.Attribute[Text] = ...
    id: bb.Attribute[Text] = ...
    client_modified: bb.Attribute[datetime.datetime] = ...
    server_modified: bb.Attribute[datetime.datetime] = ...
    rev: bb.Attribute[Text] = ...
    size: bb.Attribute[int] = ...
    path_lower: bb.Attribute[Optional[Text]] = ...
    path_display: bb.Attribute[Optional[Text]] = ...
    parent_shared_folder_id: bb.Attribute[Optional[Text]] = ...
    media_info: bb.Attribute[Optional[MediaInfo]] = ...
    symlink_info: bb.Attribute[Optional[SymlinkInfo]] = ...
    sharing_info: bb.Attribute[Optional[FileSharingInfo]] = ...
    is_downloadable: bb.Attribute[bool] = ...
    export_info: bb.Attribute[Optional[ExportInfo]] = ...
    property_groups: bb.Attribute[Optional[List[file_properties.PropertyGroup]]] = ...
    has_explicit_shared_members: bb.Attribute[Optional[bool]] = ...
    content_hash: bb.Attribute[Optional[Text]] = ...
    file_lock_info: bb.Attribute[Optional[FileLockMetadata]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileMetadata_validator: bv.Validator = ...

class SharingInfo(bb.Struct):
    def __init__(self,
                 read_only: bool = ...) -> None: ...
    read_only: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharingInfo_validator: bv.Validator = ...

class FileSharingInfo(SharingInfo):
    def __init__(self,
                 read_only: bool = ...,
                 parent_shared_folder_id: Text = ...,
                 modified_by: Optional[Text] = ...) -> None: ...
    read_only: bb.Attribute[bool] = ...
    parent_shared_folder_id: bb.Attribute[Text] = ...
    modified_by: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileSharingInfo_validator: bv.Validator = ...

class FileStatus(bb.Union):
    active: FileStatus = ...
    deleted: FileStatus = ...
    other: FileStatus = ...

    def is_active(self) -> bool: ...

    def is_deleted(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileStatus_validator: bv.Validator = ...

class FolderMetadata(Metadata):
    def __init__(self,
                 name: Text = ...,
                 id: Text = ...,
                 path_lower: Optional[Text] = ...,
                 path_display: Optional[Text] = ...,
                 parent_shared_folder_id: Optional[Text] = ...,
                 shared_folder_id: Optional[Text] = ...,
                 sharing_info: Optional[FolderSharingInfo] = ...,
                 property_groups: Optional[List[file_properties.PropertyGroup]] = ...) -> None: ...
    name: bb.Attribute[Text] = ...
    id: bb.Attribute[Text] = ...
    path_lower: bb.Attribute[Optional[Text]] = ...
    path_display: bb.Attribute[Optional[Text]] = ...
    parent_shared_folder_id: bb.Attribute[Optional[Text]] = ...
    shared_folder_id: bb.Attribute[Optional[Text]] = ...
    sharing_info: bb.Attribute[Optional[FolderSharingInfo]] = ...
    property_groups: bb.Attribute[Optional[List[file_properties.PropertyGroup]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FolderMetadata_validator: bv.Validator = ...

class FolderSharingInfo(SharingInfo):
    def __init__(self,
                 read_only: bool = ...,
                 parent_shared_folder_id: Optional[Text] = ...,
                 shared_folder_id: Optional[Text] = ...,
                 traverse_only: Optional[bool] = ...,
                 no_access: Optional[bool] = ...) -> None: ...
    read_only: bb.Attribute[bool] = ...
    parent_shared_folder_id: bb.Attribute[Optional[Text]] = ...
    shared_folder_id: bb.Attribute[Optional[Text]] = ...
    traverse_only: bb.Attribute[bool] = ...
    no_access: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FolderSharingInfo_validator: bv.Validator = ...

class GetCopyReferenceArg(bb.Struct):
    def __init__(self,
                 path: Text = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetCopyReferenceArg_validator: bv.Validator = ...

class GetCopyReferenceError(bb.Union):
    other: GetCopyReferenceError = ...

    def is_path(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> GetCopyReferenceError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetCopyReferenceError_validator: bv.Validator = ...

class GetCopyReferenceResult(bb.Struct):
    def __init__(self,
                 metadata: Metadata = ...,
                 copy_reference: Text = ...,
                 expires: datetime.datetime = ...) -> None: ...
    metadata: bb.Attribute[Metadata] = ...
    copy_reference: bb.Attribute[Text] = ...
    expires: bb.Attribute[datetime.datetime] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetCopyReferenceResult_validator: bv.Validator = ...

class GetTagsArg(bb.Struct):
    def __init__(self,
                 paths: List[Text] = ...) -> None: ...
    paths: bb.Attribute[List[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetTagsArg_validator: bv.Validator = ...

class GetTagsResult(bb.Struct):
    def __init__(self,
                 paths_to_tags: List[PathToTags] = ...) -> None: ...
    paths_to_tags: bb.Attribute[List[PathToTags]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetTagsResult_validator: bv.Validator = ...

class GetTemporaryLinkArg(bb.Struct):
    def __init__(self,
                 path: Text = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetTemporaryLinkArg_validator: bv.Validator = ...

class GetTemporaryLinkError(bb.Union):
    email_not_verified: GetTemporaryLinkError = ...
    unsupported_file: GetTemporaryLinkError = ...
    not_allowed: GetTemporaryLinkError = ...
    other: GetTemporaryLinkError = ...

    def is_path(self) -> bool: ...

    def is_email_not_verified(self) -> bool: ...

    def is_unsupported_file(self) -> bool: ...

    def is_not_allowed(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> GetTemporaryLinkError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetTemporaryLinkError_validator: bv.Validator = ...

class GetTemporaryLinkResult(bb.Struct):
    def __init__(self,
                 metadata: FileMetadata = ...,
                 link: Text = ...) -> None: ...
    metadata: bb.Attribute[FileMetadata] = ...
    link: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetTemporaryLinkResult_validator: bv.Validator = ...

class GetTemporaryUploadLinkArg(bb.Struct):
    def __init__(self,
                 commit_info: CommitInfo = ...,
                 duration: Optional[float] = ...) -> None: ...
    commit_info: bb.Attribute[CommitInfo] = ...
    duration: bb.Attribute[float] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetTemporaryUploadLinkArg_validator: bv.Validator = ...

class GetTemporaryUploadLinkResult(bb.Struct):
    def __init__(self,
                 link: Text = ...) -> None: ...
    link: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetTemporaryUploadLinkResult_validator: bv.Validator = ...

class GetThumbnailBatchArg(bb.Struct):
    def __init__(self,
                 entries: List[ThumbnailArg] = ...) -> None: ...
    entries: bb.Attribute[List[ThumbnailArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetThumbnailBatchArg_validator: bv.Validator = ...

class GetThumbnailBatchError(bb.Union):
    too_many_files: GetThumbnailBatchError = ...
    other: GetThumbnailBatchError = ...

    def is_too_many_files(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetThumbnailBatchError_validator: bv.Validator = ...

class GetThumbnailBatchResult(bb.Struct):
    def __init__(self,
                 entries: List[GetThumbnailBatchResultEntry] = ...) -> None: ...
    entries: bb.Attribute[List[GetThumbnailBatchResultEntry]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetThumbnailBatchResult_validator: bv.Validator = ...

class GetThumbnailBatchResultData(bb.Struct):
    def __init__(self,
                 metadata: FileMetadata = ...,
                 thumbnail: Text = ...) -> None: ...
    metadata: bb.Attribute[FileMetadata] = ...
    thumbnail: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetThumbnailBatchResultData_validator: bv.Validator = ...

class GetThumbnailBatchResultEntry(bb.Union):
    other: GetThumbnailBatchResultEntry = ...

    def is_success(self) -> bool: ...

    def is_failure(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: GetThumbnailBatchResultData) -> GetThumbnailBatchResultEntry: ...

    @classmethod
    def failure(cls, val: ThumbnailError) -> GetThumbnailBatchResultEntry: ...

    def get_success(self) -> GetThumbnailBatchResultData: ...

    def get_failure(self) -> ThumbnailError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetThumbnailBatchResultEntry_validator: bv.Validator = ...

class GpsCoordinates(bb.Struct):
    def __init__(self,
                 latitude: float = ...,
                 longitude: float = ...) -> None: ...
    latitude: bb.Attribute[float] = ...
    longitude: bb.Attribute[float] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GpsCoordinates_validator: bv.Validator = ...

class HighlightSpan(bb.Struct):
    def __init__(self,
                 highlight_str: Text = ...,
                 is_highlighted: bool = ...) -> None: ...
    highlight_str: bb.Attribute[Text] = ...
    is_highlighted: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

HighlightSpan_validator: bv.Validator = ...

class ImportFormat(bb.Union):
    html: ImportFormat = ...
    markdown: ImportFormat = ...
    plain_text: ImportFormat = ...
    other: ImportFormat = ...

    def is_html(self) -> bool: ...

    def is_markdown(self) -> bool: ...

    def is_plain_text(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ImportFormat_validator: bv.Validator = ...

class ListFolderArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 recursive: Optional[bool] = ...,
                 include_media_info: Optional[bool] = ...,
                 include_deleted: Optional[bool] = ...,
                 include_has_explicit_shared_members: Optional[bool] = ...,
                 include_mounted_folders: Optional[bool] = ...,
                 limit: Optional[int] = ...,
                 shared_link: Optional[SharedLink] = ...,
                 include_property_groups: Optional[file_properties.TemplateFilterBase] = ...,
                 include_non_downloadable_files: Optional[bool] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    recursive: bb.Attribute[bool] = ...
    include_media_info: bb.Attribute[bool] = ...
    include_deleted: bb.Attribute[bool] = ...
    include_has_explicit_shared_members: bb.Attribute[bool] = ...
    include_mounted_folders: bb.Attribute[bool] = ...
    limit: bb.Attribute[Optional[int]] = ...
    shared_link: bb.Attribute[Optional[SharedLink]] = ...
    include_property_groups: bb.Attribute[Optional[file_properties.TemplateFilterBase]] = ...
    include_non_downloadable_files: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderArg_validator: bv.Validator = ...

class ListFolderContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderContinueArg_validator: bv.Validator = ...

class ListFolderContinueError(bb.Union):
    reset: ListFolderContinueError = ...
    other: ListFolderContinueError = ...

    def is_path(self) -> bool: ...

    def is_reset(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> ListFolderContinueError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderContinueError_validator: bv.Validator = ...

class ListFolderError(bb.Union):
    other: ListFolderError = ...

    def is_path(self) -> bool: ...

    def is_template_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> ListFolderError: ...

    @classmethod
    def template_error(cls, val: file_properties.TemplateError) -> ListFolderError: ...

    def get_path(self) -> LookupError: ...

    def get_template_error(self) -> file_properties.TemplateError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderError_validator: bv.Validator = ...

class ListFolderGetLatestCursorResult(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderGetLatestCursorResult_validator: bv.Validator = ...

class ListFolderLongpollArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...,
                 timeout: Optional[int] = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    timeout: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderLongpollArg_validator: bv.Validator = ...

class ListFolderLongpollError(bb.Union):
    reset: ListFolderLongpollError = ...
    other: ListFolderLongpollError = ...

    def is_reset(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderLongpollError_validator: bv.Validator = ...

class ListFolderLongpollResult(bb.Struct):
    def __init__(self,
                 changes: bool = ...,
                 backoff: Optional[int] = ...) -> None: ...
    changes: bb.Attribute[bool] = ...
    backoff: bb.Attribute[Optional[int]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderLongpollResult_validator: bv.Validator = ...

class ListFolderResult(bb.Struct):
    def __init__(self,
                 entries: List[Metadata] = ...,
                 cursor: Text = ...,
                 has_more: bool = ...) -> None: ...
    entries: bb.Attribute[List[Metadata]] = ...
    cursor: bb.Attribute[Text] = ...
    has_more: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListFolderResult_validator: bv.Validator = ...

class ListRevisionsArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 mode: Optional[ListRevisionsMode] = ...,
                 limit: Optional[int] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    mode: bb.Attribute[ListRevisionsMode] = ...
    limit: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListRevisionsArg_validator: bv.Validator = ...

class ListRevisionsError(bb.Union):
    other: ListRevisionsError = ...

    def is_path(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> ListRevisionsError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListRevisionsError_validator: bv.Validator = ...

class ListRevisionsMode(bb.Union):
    path: ListRevisionsMode = ...
    id: ListRevisionsMode = ...
    other: ListRevisionsMode = ...

    def is_path(self) -> bool: ...

    def is_id(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListRevisionsMode_validator: bv.Validator = ...

class ListRevisionsResult(bb.Struct):
    def __init__(self,
                 is_deleted: bool = ...,
                 entries: List[FileMetadata] = ...,
                 server_deleted: Optional[datetime.datetime] = ...) -> None: ...
    is_deleted: bb.Attribute[bool] = ...
    entries: bb.Attribute[List[FileMetadata]] = ...
    server_deleted: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ListRevisionsResult_validator: bv.Validator = ...

class LockConflictError(bb.Struct):
    def __init__(self,
                 lock: FileLock = ...) -> None: ...
    lock: bb.Attribute[FileLock] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LockConflictError_validator: bv.Validator = ...

class LockFileArg(bb.Struct):
    def __init__(self,
                 path: Text = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LockFileArg_validator: bv.Validator = ...

class LockFileBatchArg(bb.Struct):
    def __init__(self,
                 entries: List[LockFileArg] = ...) -> None: ...
    entries: bb.Attribute[List[LockFileArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LockFileBatchArg_validator: bv.Validator = ...

class LockFileBatchResult(FileOpsResult):
    def __init__(self,
                 entries: List[LockFileResultEntry] = ...) -> None: ...
    entries: bb.Attribute[List[LockFileResultEntry]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LockFileBatchResult_validator: bv.Validator = ...

class LockFileError(bb.Union):
    too_many_write_operations: LockFileError = ...
    too_many_files: LockFileError = ...
    no_write_permission: LockFileError = ...
    cannot_be_locked: LockFileError = ...
    file_not_shared: LockFileError = ...
    internal_error: LockFileError = ...
    other: LockFileError = ...

    def is_path_lookup(self) -> bool: ...

    def is_too_many_write_operations(self) -> bool: ...

    def is_too_many_files(self) -> bool: ...

    def is_no_write_permission(self) -> bool: ...

    def is_cannot_be_locked(self) -> bool: ...

    def is_file_not_shared(self) -> bool: ...

    def is_lock_conflict(self) -> bool: ...

    def is_internal_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path_lookup(cls, val: LookupError) -> LockFileError: ...

    @classmethod
    def lock_conflict(cls, val: LockConflictError) -> LockFileError: ...

    def get_path_lookup(self) -> LookupError: ...

    def get_lock_conflict(self) -> LockConflictError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LockFileError_validator: bv.Validator = ...

class LockFileResult(bb.Struct):
    def __init__(self,
                 metadata: Metadata = ...,
                 lock: FileLock = ...) -> None: ...
    metadata: bb.Attribute[Metadata] = ...
    lock: bb.Attribute[FileLock] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LockFileResult_validator: bv.Validator = ...

class LockFileResultEntry(bb.Union):
    def is_success(self) -> bool: ...

    def is_failure(self) -> bool: ...

    @classmethod
    def success(cls, val: LockFileResult) -> LockFileResultEntry: ...

    @classmethod
    def failure(cls, val: LockFileError) -> LockFileResultEntry: ...

    def get_success(self) -> LockFileResult: ...

    def get_failure(self) -> LockFileError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LockFileResultEntry_validator: bv.Validator = ...

class LookupError(bb.Union):
    not_found: LookupError = ...
    not_file: LookupError = ...
    not_folder: LookupError = ...
    restricted_content: LookupError = ...
    unsupported_content_type: LookupError = ...
    locked: LookupError = ...
    other: LookupError = ...

    def is_malformed_path(self) -> bool: ...

    def is_not_found(self) -> bool: ...

    def is_not_file(self) -> bool: ...

    def is_not_folder(self) -> bool: ...

    def is_restricted_content(self) -> bool: ...

    def is_unsupported_content_type(self) -> bool: ...

    def is_locked(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def malformed_path(cls, val: Optional[Text]) -> LookupError: ...

    def get_malformed_path(self) -> Optional[Text]: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

LookupError_validator: bv.Validator = ...

class MediaInfo(bb.Union):
    pending: MediaInfo = ...

    def is_pending(self) -> bool: ...

    def is_metadata(self) -> bool: ...

    @classmethod
    def metadata(cls, val: MediaMetadata) -> MediaInfo: ...

    def get_metadata(self) -> MediaMetadata: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MediaInfo_validator: bv.Validator = ...

class MediaMetadata(bb.Struct):
    def __init__(self,
                 dimensions: Optional[Dimensions] = ...,
                 location: Optional[GpsCoordinates] = ...,
                 time_taken: Optional[datetime.datetime] = ...) -> None: ...
    dimensions: bb.Attribute[Optional[Dimensions]] = ...
    location: bb.Attribute[Optional[GpsCoordinates]] = ...
    time_taken: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MediaMetadata_validator: bv.Validator = ...

class MetadataV2(bb.Union):
    other: MetadataV2 = ...

    def is_metadata(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def metadata(cls, val: Metadata) -> MetadataV2: ...

    def get_metadata(self) -> Metadata: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MetadataV2_validator: bv.Validator = ...

class MinimalFileLinkMetadata(bb.Struct):
    def __init__(self,
                 url: Text = ...,
                 rev: Text = ...,
                 id: Optional[Text] = ...,
                 path: Optional[Text] = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    rev: bb.Attribute[Text] = ...
    id: bb.Attribute[Optional[Text]] = ...
    path: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MinimalFileLinkMetadata_validator: bv.Validator = ...

class RelocationBatchArgBase(bb.Struct):
    def __init__(self,
                 entries: List[RelocationPath] = ...,
                 autorename: Optional[bool] = ...) -> None: ...
    entries: bb.Attribute[List[RelocationPath]] = ...
    autorename: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchArgBase_validator: bv.Validator = ...

class MoveBatchArg(RelocationBatchArgBase):
    def __init__(self,
                 entries: List[RelocationPath] = ...,
                 autorename: Optional[bool] = ...,
                 allow_ownership_transfer: Optional[bool] = ...) -> None: ...
    entries: bb.Attribute[List[RelocationPath]] = ...
    autorename: bb.Attribute[bool] = ...
    allow_ownership_transfer: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MoveBatchArg_validator: bv.Validator = ...

class MoveIntoFamilyError(bb.Union):
    is_shared_folder: MoveIntoFamilyError = ...
    other: MoveIntoFamilyError = ...

    def is_is_shared_folder(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MoveIntoFamilyError_validator: bv.Validator = ...

class MoveIntoVaultError(bb.Union):
    is_shared_folder: MoveIntoVaultError = ...
    other: MoveIntoVaultError = ...

    def is_is_shared_folder(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

MoveIntoVaultError_validator: bv.Validator = ...

class PaperContentError(bb.Union):
    insufficient_permissions: PaperContentError = ...
    content_malformed: PaperContentError = ...
    doc_length_exceeded: PaperContentError = ...
    image_size_exceeded: PaperContentError = ...
    other: PaperContentError = ...

    def is_insufficient_permissions(self) -> bool: ...

    def is_content_malformed(self) -> bool: ...

    def is_doc_length_exceeded(self) -> bool: ...

    def is_image_size_exceeded(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PaperContentError_validator: bv.Validator = ...

class PaperCreateArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 import_format: ImportFormat = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    import_format: bb.Attribute[ImportFormat] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PaperCreateArg_validator: bv.Validator = ...

class PaperCreateError(PaperContentError):
    invalid_path: PaperCreateError = ...
    email_unverified: PaperCreateError = ...
    invalid_file_extension: PaperCreateError = ...
    paper_disabled: PaperCreateError = ...

    def is_invalid_path(self) -> bool: ...

    def is_email_unverified(self) -> bool: ...

    def is_invalid_file_extension(self) -> bool: ...

    def is_paper_disabled(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PaperCreateError_validator: bv.Validator = ...

class PaperCreateResult(bb.Struct):
    def __init__(self,
                 url: Text = ...,
                 result_path: Text = ...,
                 file_id: Text = ...,
                 paper_revision: int = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    result_path: bb.Attribute[Text] = ...
    file_id: bb.Attribute[Text] = ...
    paper_revision: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PaperCreateResult_validator: bv.Validator = ...

class PaperDocUpdatePolicy(bb.Union):
    update: PaperDocUpdatePolicy = ...
    overwrite: PaperDocUpdatePolicy = ...
    prepend: PaperDocUpdatePolicy = ...
    append: PaperDocUpdatePolicy = ...
    other: PaperDocUpdatePolicy = ...

    def is_update(self) -> bool: ...

    def is_overwrite(self) -> bool: ...

    def is_prepend(self) -> bool: ...

    def is_append(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PaperDocUpdatePolicy_validator: bv.Validator = ...

class PaperUpdateArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 import_format: ImportFormat = ...,
                 doc_update_policy: PaperDocUpdatePolicy = ...,
                 paper_revision: Optional[int] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    import_format: bb.Attribute[ImportFormat] = ...
    doc_update_policy: bb.Attribute[PaperDocUpdatePolicy] = ...
    paper_revision: bb.Attribute[Optional[int]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PaperUpdateArg_validator: bv.Validator = ...

class PaperUpdateError(PaperContentError):
    revision_mismatch: PaperUpdateError = ...
    doc_archived: PaperUpdateError = ...
    doc_deleted: PaperUpdateError = ...

    def is_path(self) -> bool: ...

    def is_revision_mismatch(self) -> bool: ...

    def is_doc_archived(self) -> bool: ...

    def is_doc_deleted(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> PaperUpdateError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PaperUpdateError_validator: bv.Validator = ...

class PaperUpdateResult(bb.Struct):
    def __init__(self,
                 paper_revision: int = ...) -> None: ...
    paper_revision: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PaperUpdateResult_validator: bv.Validator = ...

class PathOrLink(bb.Union):
    other: PathOrLink = ...

    def is_path(self) -> bool: ...

    def is_link(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: Text) -> PathOrLink: ...

    @classmethod
    def link(cls, val: SharedLinkFileInfo) -> PathOrLink: ...

    def get_path(self) -> Text: ...

    def get_link(self) -> SharedLinkFileInfo: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PathOrLink_validator: bv.Validator = ...

class PathToTags(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 tags: List[Tag] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    tags: bb.Attribute[List[Tag]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PathToTags_validator: bv.Validator = ...

class PhotoMetadata(MediaMetadata):
    def __init__(self,
                 dimensions: Optional[Dimensions] = ...,
                 location: Optional[GpsCoordinates] = ...,
                 time_taken: Optional[datetime.datetime] = ...) -> None: ...
    dimensions: bb.Attribute[Optional[Dimensions]] = ...
    location: bb.Attribute[Optional[GpsCoordinates]] = ...
    time_taken: bb.Attribute[Optional[datetime.datetime]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PhotoMetadata_validator: bv.Validator = ...

class PreviewArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 rev: Optional[Text] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    rev: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PreviewArg_validator: bv.Validator = ...

class PreviewError(bb.Union):
    in_progress: PreviewError = ...
    unsupported_extension: PreviewError = ...
    unsupported_content: PreviewError = ...

    def is_path(self) -> bool: ...

    def is_in_progress(self) -> bool: ...

    def is_unsupported_extension(self) -> bool: ...

    def is_unsupported_content(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> PreviewError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PreviewError_validator: bv.Validator = ...

class PreviewResult(bb.Struct):
    def __init__(self,
                 file_metadata: Optional[FileMetadata] = ...,
                 link_metadata: Optional[MinimalFileLinkMetadata] = ...) -> None: ...
    file_metadata: bb.Attribute[Optional[FileMetadata]] = ...
    link_metadata: bb.Attribute[Optional[MinimalFileLinkMetadata]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PreviewResult_validator: bv.Validator = ...

class RelocationPath(bb.Struct):
    def __init__(self,
                 from_path: Text = ...,
                 to_path: Text = ...) -> None: ...
    from_path: bb.Attribute[Text] = ...
    to_path: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationPath_validator: bv.Validator = ...

class RelocationArg(RelocationPath):
    def __init__(self,
                 from_path: Text = ...,
                 to_path: Text = ...,
                 allow_shared_folder: Optional[bool] = ...,
                 autorename: Optional[bool] = ...,
                 allow_ownership_transfer: Optional[bool] = ...) -> None: ...
    from_path: bb.Attribute[Text] = ...
    to_path: bb.Attribute[Text] = ...
    allow_shared_folder: bb.Attribute[bool] = ...
    autorename: bb.Attribute[bool] = ...
    allow_ownership_transfer: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationArg_validator: bv.Validator = ...

class RelocationBatchArg(RelocationBatchArgBase):
    def __init__(self,
                 entries: List[RelocationPath] = ...,
                 autorename: Optional[bool] = ...,
                 allow_shared_folder: Optional[bool] = ...,
                 allow_ownership_transfer: Optional[bool] = ...) -> None: ...
    entries: bb.Attribute[List[RelocationPath]] = ...
    autorename: bb.Attribute[bool] = ...
    allow_shared_folder: bb.Attribute[bool] = ...
    allow_ownership_transfer: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchArg_validator: bv.Validator = ...

class RelocationError(bb.Union):
    cant_copy_shared_folder: RelocationError = ...
    cant_nest_shared_folder: RelocationError = ...
    cant_move_folder_into_itself: RelocationError = ...
    too_many_files: RelocationError = ...
    duplicated_or_nested_paths: RelocationError = ...
    cant_transfer_ownership: RelocationError = ...
    insufficient_quota: RelocationError = ...
    internal_error: RelocationError = ...
    cant_move_shared_folder: RelocationError = ...
    other: RelocationError = ...

    def is_from_lookup(self) -> bool: ...

    def is_from_write(self) -> bool: ...

    def is_to(self) -> bool: ...

    def is_cant_copy_shared_folder(self) -> bool: ...

    def is_cant_nest_shared_folder(self) -> bool: ...

    def is_cant_move_folder_into_itself(self) -> bool: ...

    def is_too_many_files(self) -> bool: ...

    def is_duplicated_or_nested_paths(self) -> bool: ...

    def is_cant_transfer_ownership(self) -> bool: ...

    def is_insufficient_quota(self) -> bool: ...

    def is_internal_error(self) -> bool: ...

    def is_cant_move_shared_folder(self) -> bool: ...

    def is_cant_move_into_vault(self) -> bool: ...

    def is_cant_move_into_family(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def from_lookup(cls, val: LookupError) -> RelocationError: ...

    @classmethod
    def from_write(cls, val: WriteError) -> RelocationError: ...

    @classmethod
    def to(cls, val: WriteError) -> RelocationError: ...

    @classmethod
    def cant_move_into_vault(cls, val: MoveIntoVaultError) -> RelocationError: ...

    @classmethod
    def cant_move_into_family(cls, val: MoveIntoFamilyError) -> RelocationError: ...

    def get_from_lookup(self) -> LookupError: ...

    def get_from_write(self) -> WriteError: ...

    def get_to(self) -> WriteError: ...

    def get_cant_move_into_vault(self) -> MoveIntoVaultError: ...

    def get_cant_move_into_family(self) -> MoveIntoFamilyError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationError_validator: bv.Validator = ...

class RelocationBatchError(RelocationError):
    too_many_write_operations: RelocationBatchError = ...

    def is_too_many_write_operations(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchError_validator: bv.Validator = ...

class RelocationBatchErrorEntry(bb.Union):
    internal_error: RelocationBatchErrorEntry = ...
    too_many_write_operations: RelocationBatchErrorEntry = ...
    other: RelocationBatchErrorEntry = ...

    def is_relocation_error(self) -> bool: ...

    def is_internal_error(self) -> bool: ...

    def is_too_many_write_operations(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def relocation_error(cls, val: RelocationError) -> RelocationBatchErrorEntry: ...

    def get_relocation_error(self) -> RelocationError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchErrorEntry_validator: bv.Validator = ...

class RelocationBatchJobStatus(async_.PollResultBase):
    def is_complete(self) -> bool: ...

    def is_failed(self) -> bool: ...

    @classmethod
    def complete(cls, val: RelocationBatchResult) -> RelocationBatchJobStatus: ...

    @classmethod
    def failed(cls, val: RelocationBatchError) -> RelocationBatchJobStatus: ...

    def get_complete(self) -> RelocationBatchResult: ...

    def get_failed(self) -> RelocationBatchError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchJobStatus_validator: bv.Validator = ...

class RelocationBatchLaunch(async_.LaunchResultBase):
    other: RelocationBatchLaunch = ...

    def is_complete(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def complete(cls, val: RelocationBatchResult) -> RelocationBatchLaunch: ...

    def get_complete(self) -> RelocationBatchResult: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchLaunch_validator: bv.Validator = ...

class RelocationBatchResult(FileOpsResult):
    def __init__(self,
                 entries: List[RelocationBatchResultData] = ...) -> None: ...
    entries: bb.Attribute[List[RelocationBatchResultData]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchResult_validator: bv.Validator = ...

class RelocationBatchResultData(bb.Struct):
    def __init__(self,
                 metadata: Metadata = ...) -> None: ...
    metadata: bb.Attribute[Metadata] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchResultData_validator: bv.Validator = ...

class RelocationBatchResultEntry(bb.Union):
    other: RelocationBatchResultEntry = ...

    def is_success(self) -> bool: ...

    def is_failure(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def success(cls, val: Metadata) -> RelocationBatchResultEntry: ...

    @classmethod
    def failure(cls, val: RelocationBatchErrorEntry) -> RelocationBatchResultEntry: ...

    def get_success(self) -> Metadata: ...

    def get_failure(self) -> RelocationBatchErrorEntry: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchResultEntry_validator: bv.Validator = ...

class RelocationBatchV2JobStatus(async_.PollResultBase):
    def is_complete(self) -> bool: ...

    @classmethod
    def complete(cls, val: RelocationBatchV2Result) -> RelocationBatchV2JobStatus: ...

    def get_complete(self) -> RelocationBatchV2Result: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchV2JobStatus_validator: bv.Validator = ...

class RelocationBatchV2Launch(async_.LaunchResultBase):
    def is_complete(self) -> bool: ...

    @classmethod
    def complete(cls, val: RelocationBatchV2Result) -> RelocationBatchV2Launch: ...

    def get_complete(self) -> RelocationBatchV2Result: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchV2Launch_validator: bv.Validator = ...

class RelocationBatchV2Result(FileOpsResult):
    def __init__(self,
                 entries: List[RelocationBatchResultEntry] = ...) -> None: ...
    entries: bb.Attribute[List[RelocationBatchResultEntry]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationBatchV2Result_validator: bv.Validator = ...

class RelocationResult(FileOpsResult):
    def __init__(self,
                 metadata: Metadata = ...) -> None: ...
    metadata: bb.Attribute[Metadata] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RelocationResult_validator: bv.Validator = ...

class RemoveTagArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 tag_text: Text = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    tag_text: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RemoveTagArg_validator: bv.Validator = ...

class RemoveTagError(BaseTagError):
    tag_not_present: RemoveTagError = ...

    def is_tag_not_present(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RemoveTagError_validator: bv.Validator = ...

class RestoreArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 rev: Text = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    rev: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RestoreArg_validator: bv.Validator = ...

class RestoreError(bb.Union):
    invalid_revision: RestoreError = ...
    in_progress: RestoreError = ...
    other: RestoreError = ...

    def is_path_lookup(self) -> bool: ...

    def is_path_write(self) -> bool: ...

    def is_invalid_revision(self) -> bool: ...

    def is_in_progress(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path_lookup(cls, val: LookupError) -> RestoreError: ...

    @classmethod
    def path_write(cls, val: WriteError) -> RestoreError: ...

    def get_path_lookup(self) -> LookupError: ...

    def get_path_write(self) -> WriteError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

RestoreError_validator: bv.Validator = ...

class SaveCopyReferenceArg(bb.Struct):
    def __init__(self,
                 copy_reference: Text = ...,
                 path: Text = ...) -> None: ...
    copy_reference: bb.Attribute[Text] = ...
    path: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SaveCopyReferenceArg_validator: bv.Validator = ...

class SaveCopyReferenceError(bb.Union):
    invalid_copy_reference: SaveCopyReferenceError = ...
    no_permission: SaveCopyReferenceError = ...
    not_found: SaveCopyReferenceError = ...
    too_many_files: SaveCopyReferenceError = ...
    other: SaveCopyReferenceError = ...

    def is_path(self) -> bool: ...

    def is_invalid_copy_reference(self) -> bool: ...

    def is_no_permission(self) -> bool: ...

    def is_not_found(self) -> bool: ...

    def is_too_many_files(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: WriteError) -> SaveCopyReferenceError: ...

    def get_path(self) -> WriteError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SaveCopyReferenceError_validator: bv.Validator = ...

class SaveCopyReferenceResult(bb.Struct):
    def __init__(self,
                 metadata: Metadata = ...) -> None: ...
    metadata: bb.Attribute[Metadata] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SaveCopyReferenceResult_validator: bv.Validator = ...

class SaveUrlArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 url: Text = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    url: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SaveUrlArg_validator: bv.Validator = ...

class SaveUrlError(bb.Union):
    download_failed: SaveUrlError = ...
    invalid_url: SaveUrlError = ...
    not_found: SaveUrlError = ...
    other: SaveUrlError = ...

    def is_path(self) -> bool: ...

    def is_download_failed(self) -> bool: ...

    def is_invalid_url(self) -> bool: ...

    def is_not_found(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: WriteError) -> SaveUrlError: ...

    def get_path(self) -> WriteError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SaveUrlError_validator: bv.Validator = ...

class SaveUrlJobStatus(async_.PollResultBase):
    def is_complete(self) -> bool: ...

    def is_failed(self) -> bool: ...

    @classmethod
    def complete(cls, val: FileMetadata) -> SaveUrlJobStatus: ...

    @classmethod
    def failed(cls, val: SaveUrlError) -> SaveUrlJobStatus: ...

    def get_complete(self) -> FileMetadata: ...

    def get_failed(self) -> SaveUrlError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SaveUrlJobStatus_validator: bv.Validator = ...

class SaveUrlResult(async_.LaunchResultBase):
    def is_complete(self) -> bool: ...

    @classmethod
    def complete(cls, val: FileMetadata) -> SaveUrlResult: ...

    def get_complete(self) -> FileMetadata: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SaveUrlResult_validator: bv.Validator = ...

class SearchArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 query: Text = ...,
                 start: Optional[int] = ...,
                 max_results: Optional[int] = ...,
                 mode: Optional[SearchMode] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    query: bb.Attribute[Text] = ...
    start: bb.Attribute[int] = ...
    max_results: bb.Attribute[int] = ...
    mode: bb.Attribute[SearchMode] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchArg_validator: bv.Validator = ...

class SearchError(bb.Union):
    internal_error: SearchError = ...
    other: SearchError = ...

    def is_path(self) -> bool: ...

    def is_invalid_argument(self) -> bool: ...

    def is_internal_error(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> SearchError: ...

    @classmethod
    def invalid_argument(cls, val: Optional[Text]) -> SearchError: ...

    def get_path(self) -> LookupError: ...

    def get_invalid_argument(self) -> Optional[Text]: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchError_validator: bv.Validator = ...

class SearchMatch(bb.Struct):
    def __init__(self,
                 match_type: SearchMatchType = ...,
                 metadata: Metadata = ...) -> None: ...
    match_type: bb.Attribute[SearchMatchType] = ...
    metadata: bb.Attribute[Metadata] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchMatch_validator: bv.Validator = ...

class SearchMatchFieldOptions(bb.Struct):
    def __init__(self,
                 include_highlights: Optional[bool] = ...) -> None: ...
    include_highlights: bb.Attribute[bool] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchMatchFieldOptions_validator: bv.Validator = ...

class SearchMatchType(bb.Union):
    filename: SearchMatchType = ...
    content: SearchMatchType = ...
    both: SearchMatchType = ...

    def is_filename(self) -> bool: ...

    def is_content(self) -> bool: ...

    def is_both(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchMatchType_validator: bv.Validator = ...

class SearchMatchTypeV2(bb.Union):
    filename: SearchMatchTypeV2 = ...
    file_content: SearchMatchTypeV2 = ...
    filename_and_content: SearchMatchTypeV2 = ...
    image_content: SearchMatchTypeV2 = ...
    other: SearchMatchTypeV2 = ...

    def is_filename(self) -> bool: ...

    def is_file_content(self) -> bool: ...

    def is_filename_and_content(self) -> bool: ...

    def is_image_content(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchMatchTypeV2_validator: bv.Validator = ...

class SearchMatchV2(bb.Struct):
    def __init__(self,
                 metadata: MetadataV2 = ...,
                 match_type: Optional[SearchMatchTypeV2] = ...,
                 highlight_spans: Optional[List[HighlightSpan]] = ...) -> None: ...
    metadata: bb.Attribute[MetadataV2] = ...
    match_type: bb.Attribute[Optional[SearchMatchTypeV2]] = ...
    highlight_spans: bb.Attribute[Optional[List[HighlightSpan]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchMatchV2_validator: bv.Validator = ...

class SearchMode(bb.Union):
    filename: SearchMode = ...
    filename_and_content: SearchMode = ...
    deleted_filename: SearchMode = ...

    def is_filename(self) -> bool: ...

    def is_filename_and_content(self) -> bool: ...

    def is_deleted_filename(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchMode_validator: bv.Validator = ...

class SearchOptions(bb.Struct):
    def __init__(self,
                 path: Optional[Text] = ...,
                 max_results: Optional[int] = ...,
                 order_by: Optional[SearchOrderBy] = ...,
                 file_status: Optional[FileStatus] = ...,
                 filename_only: Optional[bool] = ...,
                 file_extensions: Optional[List[Text]] = ...,
                 file_categories: Optional[List[FileCategory]] = ...) -> None: ...
    path: bb.Attribute[Optional[Text]] = ...
    max_results: bb.Attribute[int] = ...
    order_by: bb.Attribute[Optional[SearchOrderBy]] = ...
    file_status: bb.Attribute[FileStatus] = ...
    filename_only: bb.Attribute[bool] = ...
    file_extensions: bb.Attribute[Optional[List[Text]]] = ...
    file_categories: bb.Attribute[Optional[List[FileCategory]]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchOptions_validator: bv.Validator = ...

class SearchOrderBy(bb.Union):
    relevance: SearchOrderBy = ...
    last_modified_time: SearchOrderBy = ...
    other: SearchOrderBy = ...

    def is_relevance(self) -> bool: ...

    def is_last_modified_time(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchOrderBy_validator: bv.Validator = ...

class SearchResult(bb.Struct):
    def __init__(self,
                 matches: List[SearchMatch] = ...,
                 more: bool = ...,
                 start: int = ...) -> None: ...
    matches: bb.Attribute[List[SearchMatch]] = ...
    more: bb.Attribute[bool] = ...
    start: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchResult_validator: bv.Validator = ...

class SearchV2Arg(bb.Struct):
    def __init__(self,
                 query: Text = ...,
                 options: Optional[SearchOptions] = ...,
                 match_field_options: Optional[SearchMatchFieldOptions] = ...,
                 include_highlights: Optional[bool] = ...) -> None: ...
    query: bb.Attribute[Text] = ...
    options: bb.Attribute[Optional[SearchOptions]] = ...
    match_field_options: bb.Attribute[Optional[SearchMatchFieldOptions]] = ...
    include_highlights: bb.Attribute[Optional[bool]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchV2Arg_validator: bv.Validator = ...

class SearchV2ContinueArg(bb.Struct):
    def __init__(self,
                 cursor: Text = ...) -> None: ...
    cursor: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchV2ContinueArg_validator: bv.Validator = ...

class SearchV2Result(bb.Struct):
    def __init__(self,
                 matches: List[SearchMatchV2] = ...,
                 has_more: bool = ...,
                 cursor: Optional[Text] = ...) -> None: ...
    matches: bb.Attribute[List[SearchMatchV2]] = ...
    has_more: bb.Attribute[bool] = ...
    cursor: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SearchV2Result_validator: bv.Validator = ...

class SharedLink(bb.Struct):
    def __init__(self,
                 url: Text = ...,
                 password: Optional[Text] = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    password: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedLink_validator: bv.Validator = ...

class SharedLinkFileInfo(bb.Struct):
    def __init__(self,
                 url: Text = ...,
                 path: Optional[Text] = ...,
                 password: Optional[Text] = ...) -> None: ...
    url: bb.Attribute[Text] = ...
    path: bb.Attribute[Optional[Text]] = ...
    password: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SharedLinkFileInfo_validator: bv.Validator = ...

class SingleUserLock(bb.Struct):
    def __init__(self,
                 created: datetime.datetime = ...,
                 lock_holder_account_id: Text = ...,
                 lock_holder_team_id: Optional[Text] = ...) -> None: ...
    created: bb.Attribute[datetime.datetime] = ...
    lock_holder_account_id: bb.Attribute[Text] = ...
    lock_holder_team_id: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SingleUserLock_validator: bv.Validator = ...

class SymlinkInfo(bb.Struct):
    def __init__(self,
                 target: Text = ...) -> None: ...
    target: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SymlinkInfo_validator: bv.Validator = ...

class SyncSetting(bb.Union):
    default: SyncSetting = ...
    not_synced: SyncSetting = ...
    not_synced_inactive: SyncSetting = ...
    other: SyncSetting = ...

    def is_default(self) -> bool: ...

    def is_not_synced(self) -> bool: ...

    def is_not_synced_inactive(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SyncSetting_validator: bv.Validator = ...

class SyncSettingArg(bb.Union):
    default: SyncSettingArg = ...
    not_synced: SyncSettingArg = ...
    other: SyncSettingArg = ...

    def is_default(self) -> bool: ...

    def is_not_synced(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SyncSettingArg_validator: bv.Validator = ...

class SyncSettingsError(bb.Union):
    unsupported_combination: SyncSettingsError = ...
    unsupported_configuration: SyncSettingsError = ...
    other: SyncSettingsError = ...

    def is_path(self) -> bool: ...

    def is_unsupported_combination(self) -> bool: ...

    def is_unsupported_configuration(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> SyncSettingsError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SyncSettingsError_validator: bv.Validator = ...

class Tag(bb.Union):
    other: Tag = ...

    def is_user_generated_tag(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def user_generated_tag(cls, val: UserGeneratedTag) -> Tag: ...

    def get_user_generated_tag(self) -> UserGeneratedTag: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

Tag_validator: bv.Validator = ...

class ThumbnailArg(bb.Struct):
    def __init__(self,
                 path: Text = ...,
                 format: Optional[ThumbnailFormat] = ...,
                 size: Optional[ThumbnailSize] = ...,
                 mode: Optional[ThumbnailMode] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    format: bb.Attribute[ThumbnailFormat] = ...
    size: bb.Attribute[ThumbnailSize] = ...
    mode: bb.Attribute[ThumbnailMode] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ThumbnailArg_validator: bv.Validator = ...

class ThumbnailError(bb.Union):
    unsupported_extension: ThumbnailError = ...
    unsupported_image: ThumbnailError = ...
    conversion_error: ThumbnailError = ...

    def is_path(self) -> bool: ...

    def is_unsupported_extension(self) -> bool: ...

    def is_unsupported_image(self) -> bool: ...

    def is_conversion_error(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> ThumbnailError: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ThumbnailError_validator: bv.Validator = ...

class ThumbnailFormat(bb.Union):
    jpeg: ThumbnailFormat = ...
    png: ThumbnailFormat = ...

    def is_jpeg(self) -> bool: ...

    def is_png(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ThumbnailFormat_validator: bv.Validator = ...

class ThumbnailMode(bb.Union):
    strict: ThumbnailMode = ...
    bestfit: ThumbnailMode = ...
    fitone_bestfit: ThumbnailMode = ...

    def is_strict(self) -> bool: ...

    def is_bestfit(self) -> bool: ...

    def is_fitone_bestfit(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ThumbnailMode_validator: bv.Validator = ...

class ThumbnailSize(bb.Union):
    w32h32: ThumbnailSize = ...
    w64h64: ThumbnailSize = ...
    w128h128: ThumbnailSize = ...
    w256h256: ThumbnailSize = ...
    w480h320: ThumbnailSize = ...
    w640h480: ThumbnailSize = ...
    w960h640: ThumbnailSize = ...
    w1024h768: ThumbnailSize = ...
    w2048h1536: ThumbnailSize = ...

    def is_w32h32(self) -> bool: ...

    def is_w64h64(self) -> bool: ...

    def is_w128h128(self) -> bool: ...

    def is_w256h256(self) -> bool: ...

    def is_w480h320(self) -> bool: ...

    def is_w640h480(self) -> bool: ...

    def is_w960h640(self) -> bool: ...

    def is_w1024h768(self) -> bool: ...

    def is_w2048h1536(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ThumbnailSize_validator: bv.Validator = ...

class ThumbnailV2Arg(bb.Struct):
    def __init__(self,
                 resource: PathOrLink = ...,
                 format: Optional[ThumbnailFormat] = ...,
                 size: Optional[ThumbnailSize] = ...,
                 mode: Optional[ThumbnailMode] = ...) -> None: ...
    resource: bb.Attribute[PathOrLink] = ...
    format: bb.Attribute[ThumbnailFormat] = ...
    size: bb.Attribute[ThumbnailSize] = ...
    mode: bb.Attribute[ThumbnailMode] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ThumbnailV2Arg_validator: bv.Validator = ...

class ThumbnailV2Error(bb.Union):
    unsupported_extension: ThumbnailV2Error = ...
    unsupported_image: ThumbnailV2Error = ...
    conversion_error: ThumbnailV2Error = ...
    access_denied: ThumbnailV2Error = ...
    not_found: ThumbnailV2Error = ...
    other: ThumbnailV2Error = ...

    def is_path(self) -> bool: ...

    def is_unsupported_extension(self) -> bool: ...

    def is_unsupported_image(self) -> bool: ...

    def is_conversion_error(self) -> bool: ...

    def is_access_denied(self) -> bool: ...

    def is_not_found(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: LookupError) -> ThumbnailV2Error: ...

    def get_path(self) -> LookupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

ThumbnailV2Error_validator: bv.Validator = ...

class UnlockFileArg(bb.Struct):
    def __init__(self,
                 path: Text = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UnlockFileArg_validator: bv.Validator = ...

class UnlockFileBatchArg(bb.Struct):
    def __init__(self,
                 entries: List[UnlockFileArg] = ...) -> None: ...
    entries: bb.Attribute[List[UnlockFileArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UnlockFileBatchArg_validator: bv.Validator = ...

class UploadArg(CommitInfo):
    def __init__(self,
                 path: Text = ...,
                 mode: Optional[WriteMode] = ...,
                 autorename: Optional[bool] = ...,
                 client_modified: Optional[datetime.datetime] = ...,
                 mute: Optional[bool] = ...,
                 property_groups: Optional[List[file_properties.PropertyGroup]] = ...,
                 strict_conflict: Optional[bool] = ...,
                 content_hash: Optional[Text] = ...) -> None: ...
    path: bb.Attribute[Text] = ...
    mode: bb.Attribute[WriteMode] = ...
    autorename: bb.Attribute[bool] = ...
    client_modified: bb.Attribute[Optional[datetime.datetime]] = ...
    mute: bb.Attribute[bool] = ...
    property_groups: bb.Attribute[Optional[List[file_properties.PropertyGroup]]] = ...
    strict_conflict: bb.Attribute[bool] = ...
    content_hash: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadArg_validator: bv.Validator = ...

class UploadError(bb.Union):
    payload_too_large: UploadError = ...
    content_hash_mismatch: UploadError = ...
    other: UploadError = ...

    def is_path(self) -> bool: ...

    def is_properties_error(self) -> bool: ...

    def is_payload_too_large(self) -> bool: ...

    def is_content_hash_mismatch(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def path(cls, val: UploadWriteFailed) -> UploadError: ...

    @classmethod
    def properties_error(cls, val: file_properties.InvalidPropertyGroupError) -> UploadError: ...

    def get_path(self) -> UploadWriteFailed: ...

    def get_properties_error(self) -> file_properties.InvalidPropertyGroupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadError_validator: bv.Validator = ...

class UploadSessionAppendArg(bb.Struct):
    def __init__(self,
                 cursor: UploadSessionCursor = ...,
                 close: Optional[bool] = ...,
                 content_hash: Optional[Text] = ...) -> None: ...
    cursor: bb.Attribute[UploadSessionCursor] = ...
    close: bb.Attribute[bool] = ...
    content_hash: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionAppendArg_validator: bv.Validator = ...

class UploadSessionLookupError(bb.Union):
    not_found: UploadSessionLookupError = ...
    closed: UploadSessionLookupError = ...
    not_closed: UploadSessionLookupError = ...
    too_large: UploadSessionLookupError = ...
    concurrent_session_invalid_offset: UploadSessionLookupError = ...
    concurrent_session_invalid_data_size: UploadSessionLookupError = ...
    payload_too_large: UploadSessionLookupError = ...
    other: UploadSessionLookupError = ...

    def is_not_found(self) -> bool: ...

    def is_incorrect_offset(self) -> bool: ...

    def is_closed(self) -> bool: ...

    def is_not_closed(self) -> bool: ...

    def is_too_large(self) -> bool: ...

    def is_concurrent_session_invalid_offset(self) -> bool: ...

    def is_concurrent_session_invalid_data_size(self) -> bool: ...

    def is_payload_too_large(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def incorrect_offset(cls, val: UploadSessionOffsetError) -> UploadSessionLookupError: ...

    def get_incorrect_offset(self) -> UploadSessionOffsetError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionLookupError_validator: bv.Validator = ...

class UploadSessionAppendError(UploadSessionLookupError):
    content_hash_mismatch: UploadSessionAppendError = ...

    def is_content_hash_mismatch(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionAppendError_validator: bv.Validator = ...

class UploadSessionCursor(bb.Struct):
    def __init__(self,
                 session_id: Text = ...,
                 offset: int = ...) -> None: ...
    session_id: bb.Attribute[Text] = ...
    offset: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionCursor_validator: bv.Validator = ...

class UploadSessionFinishArg(bb.Struct):
    def __init__(self,
                 cursor: UploadSessionCursor = ...,
                 commit: CommitInfo = ...,
                 content_hash: Optional[Text] = ...) -> None: ...
    cursor: bb.Attribute[UploadSessionCursor] = ...
    commit: bb.Attribute[CommitInfo] = ...
    content_hash: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionFinishArg_validator: bv.Validator = ...

class UploadSessionFinishBatchArg(bb.Struct):
    def __init__(self,
                 entries: List[UploadSessionFinishArg] = ...) -> None: ...
    entries: bb.Attribute[List[UploadSessionFinishArg]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionFinishBatchArg_validator: bv.Validator = ...

class UploadSessionFinishBatchJobStatus(async_.PollResultBase):
    def is_complete(self) -> bool: ...

    @classmethod
    def complete(cls, val: UploadSessionFinishBatchResult) -> UploadSessionFinishBatchJobStatus: ...

    def get_complete(self) -> UploadSessionFinishBatchResult: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionFinishBatchJobStatus_validator: bv.Validator = ...

class UploadSessionFinishBatchLaunch(async_.LaunchResultBase):
    other: UploadSessionFinishBatchLaunch = ...

    def is_complete(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def complete(cls, val: UploadSessionFinishBatchResult) -> UploadSessionFinishBatchLaunch: ...

    def get_complete(self) -> UploadSessionFinishBatchResult: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionFinishBatchLaunch_validator: bv.Validator = ...

class UploadSessionFinishBatchResult(bb.Struct):
    def __init__(self,
                 entries: List[UploadSessionFinishBatchResultEntry] = ...) -> None: ...
    entries: bb.Attribute[List[UploadSessionFinishBatchResultEntry]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionFinishBatchResult_validator: bv.Validator = ...

class UploadSessionFinishBatchResultEntry(bb.Union):
    def is_success(self) -> bool: ...

    def is_failure(self) -> bool: ...

    @classmethod
    def success(cls, val: FileMetadata) -> UploadSessionFinishBatchResultEntry: ...

    @classmethod
    def failure(cls, val: UploadSessionFinishError) -> UploadSessionFinishBatchResultEntry: ...

    def get_success(self) -> FileMetadata: ...

    def get_failure(self) -> UploadSessionFinishError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionFinishBatchResultEntry_validator: bv.Validator = ...

class UploadSessionFinishError(bb.Union):
    too_many_shared_folder_targets: UploadSessionFinishError = ...
    too_many_write_operations: UploadSessionFinishError = ...
    concurrent_session_data_not_allowed: UploadSessionFinishError = ...
    concurrent_session_not_closed: UploadSessionFinishError = ...
    concurrent_session_missing_data: UploadSessionFinishError = ...
    payload_too_large: UploadSessionFinishError = ...
    content_hash_mismatch: UploadSessionFinishError = ...
    other: UploadSessionFinishError = ...

    def is_lookup_failed(self) -> bool: ...

    def is_path(self) -> bool: ...

    def is_properties_error(self) -> bool: ...

    def is_too_many_shared_folder_targets(self) -> bool: ...

    def is_too_many_write_operations(self) -> bool: ...

    def is_concurrent_session_data_not_allowed(self) -> bool: ...

    def is_concurrent_session_not_closed(self) -> bool: ...

    def is_concurrent_session_missing_data(self) -> bool: ...

    def is_payload_too_large(self) -> bool: ...

    def is_content_hash_mismatch(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def lookup_failed(cls, val: UploadSessionLookupError) -> UploadSessionFinishError: ...

    @classmethod
    def path(cls, val: WriteError) -> UploadSessionFinishError: ...

    @classmethod
    def properties_error(cls, val: file_properties.InvalidPropertyGroupError) -> UploadSessionFinishError: ...

    def get_lookup_failed(self) -> UploadSessionLookupError: ...

    def get_path(self) -> WriteError: ...

    def get_properties_error(self) -> file_properties.InvalidPropertyGroupError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionFinishError_validator: bv.Validator = ...

class UploadSessionOffsetError(bb.Struct):
    def __init__(self,
                 correct_offset: int = ...) -> None: ...
    correct_offset: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionOffsetError_validator: bv.Validator = ...

class UploadSessionStartArg(bb.Struct):
    def __init__(self,
                 close: Optional[bool] = ...,
                 session_type: Optional[UploadSessionType] = ...,
                 content_hash: Optional[Text] = ...) -> None: ...
    close: bb.Attribute[bool] = ...
    session_type: bb.Attribute[Optional[UploadSessionType]] = ...
    content_hash: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionStartArg_validator: bv.Validator = ...

class UploadSessionStartError(bb.Union):
    concurrent_session_data_not_allowed: UploadSessionStartError = ...
    concurrent_session_close_not_allowed: UploadSessionStartError = ...
    payload_too_large: UploadSessionStartError = ...
    content_hash_mismatch: UploadSessionStartError = ...
    other: UploadSessionStartError = ...

    def is_concurrent_session_data_not_allowed(self) -> bool: ...

    def is_concurrent_session_close_not_allowed(self) -> bool: ...

    def is_payload_too_large(self) -> bool: ...

    def is_content_hash_mismatch(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionStartError_validator: bv.Validator = ...

class UploadSessionStartResult(bb.Struct):
    def __init__(self,
                 session_id: Text = ...) -> None: ...
    session_id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionStartResult_validator: bv.Validator = ...

class UploadSessionType(bb.Union):
    sequential: UploadSessionType = ...
    concurrent: UploadSessionType = ...
    other: UploadSessionType = ...

    def is_sequential(self) -> bool: ...

    def is_concurrent(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadSessionType_validator: bv.Validator = ...

class UploadWriteFailed(bb.Struct):
    def __init__(self,
                 reason: WriteError = ...,
                 upload_session_id: Text = ...) -> None: ...
    reason: bb.Attribute[WriteError] = ...
    upload_session_id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UploadWriteFailed_validator: bv.Validator = ...

class UserGeneratedTag(bb.Struct):
    def __init__(self,
                 tag_text: Text = ...) -> None: ...
    tag_text: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserGeneratedTag_validator: bv.Validator = ...

class VideoMetadata(MediaMetadata):
    def __init__(self,
                 dimensions: Optional[Dimensions] = ...,
                 location: Optional[GpsCoordinates] = ...,
                 time_taken: Optional[datetime.datetime] = ...,
                 duration: Optional[int] = ...) -> None: ...
    dimensions: bb.Attribute[Optional[Dimensions]] = ...
    location: bb.Attribute[Optional[GpsCoordinates]] = ...
    time_taken: bb.Attribute[Optional[datetime.datetime]] = ...
    duration: bb.Attribute[Optional[int]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

VideoMetadata_validator: bv.Validator = ...

class WriteConflictError(bb.Union):
    file: WriteConflictError = ...
    folder: WriteConflictError = ...
    file_ancestor: WriteConflictError = ...
    other: WriteConflictError = ...

    def is_file(self) -> bool: ...

    def is_folder(self) -> bool: ...

    def is_file_ancestor(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

WriteConflictError_validator: bv.Validator = ...

class WriteError(bb.Union):
    no_write_permission: WriteError = ...
    insufficient_space: WriteError = ...
    disallowed_name: WriteError = ...
    team_folder: WriteError = ...
    operation_suppressed: WriteError = ...
    too_many_write_operations: WriteError = ...
    other: WriteError = ...

    def is_malformed_path(self) -> bool: ...

    def is_conflict(self) -> bool: ...

    def is_no_write_permission(self) -> bool: ...

    def is_insufficient_space(self) -> bool: ...

    def is_disallowed_name(self) -> bool: ...

    def is_team_folder(self) -> bool: ...

    def is_operation_suppressed(self) -> bool: ...

    def is_too_many_write_operations(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def malformed_path(cls, val: Optional[Text]) -> WriteError: ...

    @classmethod
    def conflict(cls, val: WriteConflictError) -> WriteError: ...

    def get_malformed_path(self) -> Optional[Text]: ...

    def get_conflict(self) -> WriteConflictError: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

WriteError_validator: bv.Validator = ...

class WriteMode(bb.Union):
    add: WriteMode = ...
    overwrite: WriteMode = ...

    def is_add(self) -> bool: ...

    def is_overwrite(self) -> bool: ...

    def is_update(self) -> bool: ...

    @classmethod
    def update(cls, val: Text) -> WriteMode: ...

    def get_update(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

WriteMode_validator: bv.Validator = ...

CopyBatchArg_validator: bv.Validator = ...
CopyBatchArg = RelocationBatchArgBase
FileId_validator: bv.Validator = ...
Id_validator: bv.Validator = ...
ListFolderCursor_validator: bv.Validator = ...
MalformedPathError_validator: bv.Validator = ...
Path_validator: bv.Validator = ...
PathOrId_validator: bv.Validator = ...
PathR_validator: bv.Validator = ...
PathROrId_validator: bv.Validator = ...
ReadPath_validator: bv.Validator = ...
Rev_validator: bv.Validator = ...
SearchV2Cursor_validator: bv.Validator = ...
Sha256HexHash_validator: bv.Validator = ...
SharedLinkUrl_validator: bv.Validator = ...
TagText_validator: bv.Validator = ...
WritePath_validator: bv.Validator = ...
WritePathOrId_validator: bv.Validator = ...
alpha_get_metadata: bb.Route = ...
alpha_upload: bb.Route = ...
copy_v2: bb.Route = ...
copy: bb.Route = ...
copy_batch_v2: bb.Route = ...
copy_batch: bb.Route = ...
copy_batch_check_v2: bb.Route = ...
copy_batch_check: bb.Route = ...
copy_reference_get: bb.Route = ...
copy_reference_save: bb.Route = ...
create_folder_v2: bb.Route = ...
create_folder: bb.Route = ...
create_folder_batch: bb.Route = ...
create_folder_batch_check: bb.Route = ...
delete_v2: bb.Route = ...
delete: bb.Route = ...
delete_batch: bb.Route = ...
delete_batch_check: bb.Route = ...
download: bb.Route = ...
download_zip: bb.Route = ...
export: bb.Route = ...
get_file_lock_batch: bb.Route = ...
get_metadata: bb.Route = ...
get_preview: bb.Route = ...
get_temporary_link: bb.Route = ...
get_temporary_upload_link: bb.Route = ...
get_thumbnail: bb.Route = ...
get_thumbnail_v2: bb.Route = ...
get_thumbnail_batch: bb.Route = ...
list_folder: bb.Route = ...
list_folder_continue: bb.Route = ...
list_folder_get_latest_cursor: bb.Route = ...
list_folder_longpoll: bb.Route = ...
list_revisions: bb.Route = ...
lock_file_batch: bb.Route = ...
move_v2: bb.Route = ...
move: bb.Route = ...
move_batch_v2: bb.Route = ...
move_batch: bb.Route = ...
move_batch_check_v2: bb.Route = ...
move_batch_check: bb.Route = ...
paper_create: bb.Route = ...
paper_update: bb.Route = ...
permanently_delete: bb.Route = ...
properties_add: bb.Route = ...
properties_overwrite: bb.Route = ...
properties_remove: bb.Route = ...
properties_template_get: bb.Route = ...
properties_template_list: bb.Route = ...
properties_update: bb.Route = ...
restore: bb.Route = ...
save_url: bb.Route = ...
save_url_check_job_status: bb.Route = ...
search: bb.Route = ...
search_v2: bb.Route = ...
search_continue_v2: bb.Route = ...
tags_add: bb.Route = ...
tags_get: bb.Route = ...
tags_remove: bb.Route = ...
unlock_file_batch: bb.Route = ...
upload: bb.Route = ...
upload_session_append_v2: bb.Route = ...
upload_session_append: bb.Route = ...
upload_session_finish: bb.Route = ...
upload_session_finish_batch: bb.Route = ...
upload_session_finish_batch_v2: bb.Route = ...
upload_session_finish_batch_check: bb.Route = ...
upload_session_start: bb.Route = ...


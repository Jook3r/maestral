# -*- coding: utf-8 -*-
# Auto-generated by Stone, do not modify.
# @generated
# flake8: noqa
# pylint: skip-file

from typing import (
    Callable,
    List,
    Optional,
    Text,
    Type,
    TypeVar,
)
from stone.backends.python_rsrc import stone_base as bb  # type: ignore
from stone.backends.python_rsrc import stone_validators as bv  # type: ignore

from dropbox import common  # type: ignore
from dropbox import team_common  # type: ignore
from dropbox import team_policies  # type: ignore
from dropbox import users_common  # type: ignore

T = TypeVar('T', bound=bb.AnnotationType)
U = TypeVar('U')

class Account(bb.Struct):
    def __init__(self,
                 account_id: Text = ...,
                 name: Name = ...,
                 email: Text = ...,
                 email_verified: bool = ...,
                 disabled: bool = ...,
                 profile_photo_url: Optional[Text] = ...) -> None: ...
    account_id: bb.Attribute[Text] = ...
    name: bb.Attribute[Name] = ...
    email: bb.Attribute[Text] = ...
    email_verified: bb.Attribute[bool] = ...
    disabled: bb.Attribute[bool] = ...
    profile_photo_url: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

Account_validator: bv.Validator = ...

class BasicAccount(Account):
    def __init__(self,
                 account_id: Text = ...,
                 name: Name = ...,
                 email: Text = ...,
                 email_verified: bool = ...,
                 disabled: bool = ...,
                 is_teammate: bool = ...,
                 profile_photo_url: Optional[Text] = ...,
                 team_member_id: Optional[Text] = ...) -> None: ...
    account_id: bb.Attribute[Text] = ...
    name: bb.Attribute[Name] = ...
    email: bb.Attribute[Text] = ...
    email_verified: bb.Attribute[bool] = ...
    disabled: bb.Attribute[bool] = ...
    is_teammate: bb.Attribute[bool] = ...
    profile_photo_url: bb.Attribute[Optional[Text]] = ...
    team_member_id: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

BasicAccount_validator: bv.Validator = ...

class FileLockingValue(bb.Union):
    other: FileLockingValue = ...

    def is_enabled(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def enabled(cls, val: bool) -> FileLockingValue: ...

    def get_enabled(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FileLockingValue_validator: bv.Validator = ...

class FullAccount(Account):
    def __init__(self,
                 account_id: Text = ...,
                 name: Name = ...,
                 email: Text = ...,
                 email_verified: bool = ...,
                 disabled: bool = ...,
                 locale: Text = ...,
                 referral_link: Text = ...,
                 is_paired: bool = ...,
                 account_type: users_common.AccountType = ...,
                 root_info: common.RootInfo = ...,
                 profile_photo_url: Optional[Text] = ...,
                 country: Optional[Text] = ...,
                 team: Optional[FullTeam] = ...,
                 team_member_id: Optional[Text] = ...) -> None: ...
    account_id: bb.Attribute[Text] = ...
    name: bb.Attribute[Name] = ...
    email: bb.Attribute[Text] = ...
    email_verified: bb.Attribute[bool] = ...
    disabled: bb.Attribute[bool] = ...
    locale: bb.Attribute[Text] = ...
    referral_link: bb.Attribute[Text] = ...
    is_paired: bb.Attribute[bool] = ...
    account_type: bb.Attribute[users_common.AccountType] = ...
    root_info: bb.Attribute[common.RootInfo] = ...
    profile_photo_url: bb.Attribute[Optional[Text]] = ...
    country: bb.Attribute[Optional[Text]] = ...
    team: bb.Attribute[Optional[FullTeam]] = ...
    team_member_id: bb.Attribute[Optional[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FullAccount_validator: bv.Validator = ...

class Team(bb.Struct):
    def __init__(self,
                 id: Text = ...,
                 name: Text = ...) -> None: ...
    id: bb.Attribute[Text] = ...
    name: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

Team_validator: bv.Validator = ...

class FullTeam(Team):
    def __init__(self,
                 id: Text = ...,
                 name: Text = ...,
                 sharing_policies: team_policies.TeamSharingPolicies = ...,
                 office_addin_policy: team_policies.OfficeAddInPolicy = ...) -> None: ...
    id: bb.Attribute[Text] = ...
    name: bb.Attribute[Text] = ...
    sharing_policies: bb.Attribute[team_policies.TeamSharingPolicies] = ...
    office_addin_policy: bb.Attribute[team_policies.OfficeAddInPolicy] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

FullTeam_validator: bv.Validator = ...

class GetAccountArg(bb.Struct):
    def __init__(self,
                 account_id: Text = ...) -> None: ...
    account_id: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetAccountArg_validator: bv.Validator = ...

class GetAccountBatchArg(bb.Struct):
    def __init__(self,
                 account_ids: List[Text] = ...) -> None: ...
    account_ids: bb.Attribute[List[Text]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetAccountBatchArg_validator: bv.Validator = ...

class GetAccountBatchError(bb.Union):
    other: GetAccountBatchError = ...

    def is_no_account(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def no_account(cls, val: Text) -> GetAccountBatchError: ...

    def get_no_account(self) -> Text: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetAccountBatchError_validator: bv.Validator = ...

class GetAccountError(bb.Union):
    no_account: GetAccountError = ...
    other: GetAccountError = ...

    def is_no_account(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

GetAccountError_validator: bv.Validator = ...

class IndividualSpaceAllocation(bb.Struct):
    def __init__(self,
                 allocated: int = ...) -> None: ...
    allocated: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

IndividualSpaceAllocation_validator: bv.Validator = ...

class Name(bb.Struct):
    def __init__(self,
                 given_name: Text = ...,
                 surname: Text = ...,
                 familiar_name: Text = ...,
                 display_name: Text = ...,
                 abbreviated_name: Text = ...) -> None: ...
    given_name: bb.Attribute[Text] = ...
    surname: bb.Attribute[Text] = ...
    familiar_name: bb.Attribute[Text] = ...
    display_name: bb.Attribute[Text] = ...
    abbreviated_name: bb.Attribute[Text] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

Name_validator: bv.Validator = ...

class PaperAsFilesValue(bb.Union):
    other: PaperAsFilesValue = ...

    def is_enabled(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def enabled(cls, val: bool) -> PaperAsFilesValue: ...

    def get_enabled(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

PaperAsFilesValue_validator: bv.Validator = ...

class SpaceAllocation(bb.Union):
    other: SpaceAllocation = ...

    def is_individual(self) -> bool: ...

    def is_team(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def individual(cls, val: IndividualSpaceAllocation) -> SpaceAllocation: ...

    @classmethod
    def team(cls, val: TeamSpaceAllocation) -> SpaceAllocation: ...

    def get_individual(self) -> IndividualSpaceAllocation: ...

    def get_team(self) -> TeamSpaceAllocation: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SpaceAllocation_validator: bv.Validator = ...

class SpaceUsage(bb.Struct):
    def __init__(self,
                 used: int = ...,
                 allocation: SpaceAllocation = ...) -> None: ...
    used: bb.Attribute[int] = ...
    allocation: bb.Attribute[SpaceAllocation] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

SpaceUsage_validator: bv.Validator = ...

class TeamSpaceAllocation(bb.Struct):
    def __init__(self,
                 used: int = ...,
                 allocated: int = ...,
                 user_within_team_space_allocated: int = ...,
                 user_within_team_space_limit_type: team_common.MemberSpaceLimitType = ...,
                 user_within_team_space_used_cached: int = ...) -> None: ...
    used: bb.Attribute[int] = ...
    allocated: bb.Attribute[int] = ...
    user_within_team_space_allocated: bb.Attribute[int] = ...
    user_within_team_space_limit_type: bb.Attribute[team_common.MemberSpaceLimitType] = ...
    user_within_team_space_used_cached: bb.Attribute[int] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

TeamSpaceAllocation_validator: bv.Validator = ...

class UserFeature(bb.Union):
    paper_as_files: UserFeature = ...
    file_locking: UserFeature = ...
    other: UserFeature = ...

    def is_paper_as_files(self) -> bool: ...

    def is_file_locking(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserFeature_validator: bv.Validator = ...

class UserFeatureValue(bb.Union):
    other: UserFeatureValue = ...

    def is_paper_as_files(self) -> bool: ...

    def is_file_locking(self) -> bool: ...

    def is_other(self) -> bool: ...

    @classmethod
    def paper_as_files(cls, val: PaperAsFilesValue) -> UserFeatureValue: ...

    @classmethod
    def file_locking(cls, val: FileLockingValue) -> UserFeatureValue: ...

    def get_paper_as_files(self) -> PaperAsFilesValue: ...

    def get_file_locking(self) -> FileLockingValue: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserFeatureValue_validator: bv.Validator = ...

class UserFeaturesGetValuesBatchArg(bb.Struct):
    def __init__(self,
                 features: List[UserFeature] = ...) -> None: ...
    features: bb.Attribute[List[UserFeature]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserFeaturesGetValuesBatchArg_validator: bv.Validator = ...

class UserFeaturesGetValuesBatchError(bb.Union):
    empty_features_list: UserFeaturesGetValuesBatchError = ...
    other: UserFeaturesGetValuesBatchError = ...

    def is_empty_features_list(self) -> bool: ...

    def is_other(self) -> bool: ...

    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserFeaturesGetValuesBatchError_validator: bv.Validator = ...

class UserFeaturesGetValuesBatchResult(bb.Struct):
    def __init__(self,
                 values: List[UserFeatureValue] = ...) -> None: ...
    values: bb.Attribute[List[UserFeatureValue]] = ...
    def _process_custom_annotations(
        self,
        annotation_type: Type[T],
        field_path: Text,
        processor: Callable[[T, U], U],
    ) -> None: ...

UserFeaturesGetValuesBatchResult_validator: bv.Validator = ...

GetAccountBatchResult_validator: bv.Validator = ...
features_get_values: bb.Route = ...
get_account: bb.Route = ...
get_account_batch: bb.Route = ...
get_current_account: bb.Route = ...
get_space_usage: bb.Route = ...

